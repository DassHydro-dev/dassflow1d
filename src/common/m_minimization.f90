!======================================================================================================================!
!
!                    DassFlow1D Version 2.1
!
!======================================================================================================================!
!
!  Copyright University of Toulouse-INSA - CNRS (France)
!
!  This file is part of the DassFlow software (Data Assimilation for Free Surface Flows).
!  DassFlow is a computational software aiming at simulating geophysical free surface flows.
!  It is designed for Variational Data Assimilation (4D-var) and sensitivity analyses. 
! Inverse capabilities are based on the adjoint code which is generated by 
! a source-to-source algorithmic differentiation (Tapenade software used).
!
!  DassFlow software includes few mostly independent "modules" with common architectures and structures:
!    - DassFlow 2DShallow (shallow water equations in (h,q), finite volumes), i.e. the present code.
!    - DassFlow3D  (non-linear Stokes equations, finite elements, mobile geometries, ALE).
!    - DassFlow 1D (shallow water equations in (S,Q), finite volumes or finite differences), river hydraulics.
!  Please consult the DassFlow webpage for more details: http://www.math.univ-toulouse.fr/DassFlow
!
! You have used DassFlow in an article, a scientific document etc ?  How to cite us ? Please consult the webpage.
! 
!  Many people have contributed to the DassFlow developments from the initial version to the latest ones.
!  Current main developers or scientific contributers are:
!               P. Brisset (CNES & Mathematics Institute of Toulouse & INSA Toulouse)
!               F. Couderc (CNRS & Mathematics Institute of Toulouse IMT)
!               P.-A. Garambois (INSA & ICUBE Strasbourg)
!               J. Monnier (INSA & Mathematics Institute of Toulouse IMT).
!               J.-P. Vila (INSA & Mathematics Institute of Toulouse IMT).
!  and former other developers (R. Madec, M. Honnorat and J. Marin).
!
!  Scientific contact : jerome.monnier@insa-toulouse.fr
!  Technical  contacts : frederic.couderc@math.univ-toulouse.fr, pierre.brisset@insa-toulouse.fr
!
!  This software is governed by the CeCILL license under French law and abiding by the rules of distribution
!  of free software. You can use, modify and/or redistribute the software under the terms of the CeCILL license
!  as circulated by CEA, CNRS and INRIA at the following URL: "http://www.cecill.info".
!
!  As a counterpart to the access to the source code and rights to copy, modify and redistribute granted by the
!  license, users are provided only with a limited warranty and the software's author, the holder of the economic
!  rights, and the successive licensors have only limited liability.
!
!  In this respect, the user's attention is drawn to the risks associated with loading, using, modifying and/or
!  developing or reproducing the software by the user in light of its specific status of free software, that may
!  mean that it is complicated to manipulate, and that also therefore means that it is reserved for developers and
!  experienced professionals having in-depth computer knowledge. Users are therefore encouraged to load and test the
!  software's suitability as regards their requirements in conditions enabling the security of their systems and/or
!  data to be ensured and, more generally, to use and operate it in the same conditions as regards security.
!
!  The fact that you are presently reading this means that you have had knowledge of the CeCILL license and that you
!  accept its terms.
!
!======================================================================================================================!
!> \file m_mesh.f90
!! \brief This file includes m_mesh module.
!! \details The file includes only m_mesh module (see doc m_mesh module).

!**********************************************************************************************************************!
!**********************************************************************************************************************!
!
!  Module m_mesh
!
!**********************************************************************************************************************!
!**********************************************************************************************************************!

!> Module m_mesh.
!!
!! \details This module includes mesh, cross section and point structure and subroutine alloc/deallocation of the
!! cross section
module m_minimization
    use m_common
    implicit none
    
#ifdef USE_M1QN3
    type M1QN3Comm
        integer(ip) :: impres
        integer(ip) :: indic
        integer(ip) :: io
        integer(ip) :: omode
        integer(ip) :: ndz
        integer(ip) :: niter
        integer(ip) :: nsim
        integer(ip) :: reverse
        integer(ip), dimension(3) :: imode
        integer(ip), dimension(5) :: iz
        double precision :: df1
        double precision :: dxmin
        double precision :: epsg
        double precision, dimension(:), allocatable :: dz
        character(len=3) :: normtype
    end type
    
#ifndef CPP_ADJ  
    contains
    
    
    subroutine comm_m1qn3_initialise(comm, n)
        type(M1QN3Comm), intent(inout) :: comm
        integer, intent(in) :: n
        
        comm%impres = 3
        comm%indic = 0
        comm%io = 6
        comm%omode = 0
        comm%ndz = 4 * n + 100 * (2 * n + 1)
        comm%niter = 100
        comm%nsim = 100
        comm%reverse = 0
        comm%imode(1:2) = 0
        comm%imode(3) = 1
        comm%iz(:) = 0
        comm%df1 = 0.0
        comm%df1 = 0.0
        comm%dxmin = 1.d-6
        comm%epsg = 1.d-6
        allocate(comm%dz(comm%ndz))
        comm%dz(:) = 0.d0
        comm%normtype = "two"
    end subroutine
    
    
    subroutine comm_m1qn3_finalise(comm)
        type(M1QN3Comm), intent(inout) :: comm

        if (allocated(comm%dz)) deallocate(comm%dz)
    end subroutine
  

    subroutine m1qn3_reverse_mode(n, x, f, g, comm)
        implicit none
        integer, intent(in) :: n
        double precision, dimension(n), intent(inout) :: x
        double precision, intent(in) :: f
        double precision, dimension(n), intent(in) :: g
        type(M1QN3Comm), intent(inout) :: comm
        
        integer :: izs(1)
        real :: rzs(1)
        double precision :: dzs(1)
        external  simul_rc , euclid , ctonbe , ctcabe
        
        call m1qn3(simul_rc, euclid, ctonbe, ctcabe, n, x, f, g, comm%dxmin, comm%df1, comm%epsg, comm%normtype, &
                   comm%impres, comm%io, comm%imode, comm%omode, comm%niter, comm%nsim, comm%iz, comm%dz, comm%ndz, &
                   comm%reverse, comm%indic, izs, rzs, dzs)

    end subroutine
        
#endif
#endif

end module m_minimization
