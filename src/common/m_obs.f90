!======================================================================================================================!
!
!                    DassFlow1D Version 2.1
!
!======================================================================================================================!
!
!  Copyright University of Toulouse-INSA - CNRS (France)
!
!  This file is part of the DassFlow software (Data Assimilation for Free Surface Flows).
!  DassFlow is a computational software aiming at simulating geophysical free surface flows.
!  It is designed for Variational Data Assimilation (4D-var) and sensitivity analyses. 
! Inverse capabilities are based on the adjoint code which is generated by 
! a source-to-source algorithmic differentiation (Tapenade software used).
!
!  DassFlow software includes few mostly independent "modules" with common architectures and structures:
!    - DassFlow 2DShallow (shallow water equations in (h,q), finite volumes), i.e. the present code.
!    - DassFlow3D  (non-linear Stokes equations, finite elements, mobile geometries, ALE).
!    - DassFlow 1D (shallow water equations in (S,Q), finite volumes or finite differences), river hydraulics.
!  Please consult the DassFlow webpage for more details: http://www.math.univ-toulouse.fr/DassFlow
!
! You have used DassFlow in an article, a scientific document etc ?  How to cite us ? Please consult the webpage.
! 
!  Many people have contributed to the DassFlow developments from the initial version to the latest ones.
!  Current main developers or scientific contributers are:
!               P. Brisset (CNES & Mathematics Institute of Toulouse & INSA Toulouse)
!               F. Couderc (CNRS & Mathematics Institute of Toulouse IMT)
!               P.-A. Garambois (INSA & ICUBE Strasbourg)
!               J. Monnier (INSA & Mathematics Institute of Toulouse IMT).
!               J.-P. Vila (INSA & Mathematics Institute of Toulouse IMT).
!  and former other developers (R. Madec, M. Honnorat and J. Marin).
!
!  Scientific contact : jerome.monnier@insa-toulouse.fr
!  Technical  contacts : frederic.couderc@math.univ-toulouse.fr, pierre.brisset@insa-toulouse.fr
!
!  This software is governed by the CeCILL license under French law and abiding by the rules of distribution
!  of free software. You can use, modify and/or redistribute the software under the terms of the CeCILL license
!  as circulated by CEA, CNRS and INRIA at the following URL: "http://www.cecill.info".
!
!  As a counterpart to the access to the source code and rights to copy, modify and redistribute granted by the
!  license, users are provided only with a limited warranty and the software's author, the holder of the economic
!  rights, and the successive licensors have only limited liability.
!
!  In this respect, the user's attention is drawn to the risks associated with loading, using, modifying and/or
!  developing or reproducing the software by the user in light of its specific status of free software, that may
!  mean that it is complicated to manipulate, and that also therefore means that it is reserved for developers and
!  experienced professionals having in-depth computer knowledge. Users are therefore encouraged to load and test the
!  software's suitability as regards their requirements in conditions enabling the security of their systems and/or
!  data to be ensured and, more generally, to use and operate it in the same conditions as regards security.
!
!  The fact that you are presently reading this means that you have had knowledge of the CeCILL license and that you
!  accept its terms.
!
!======================================================================================================================!
!> \file m_obs.f90
!! \brief This file includes m_obs module.
!! \details The file includes only m_obs module (see doc m_obs module).



!**********************************************************************************************************************!
!**********************************************************************************************************************!
!
!  Module using Tapenade generated Output Files in /tap directory
!
!**********************************************************************************************************************!
!**********************************************************************************************************************!

!> Module m_obs.
!!
!! \details This module includes the definition of the innovation vector. Moreover, it is in this module that the 
!! subroutine which compute cost function are defined.
module m_obs

    use m_common
    use m_mesh
    implicit none
   
   
    type ObsStation
   
        !> Indices of cross-sections
        integer(ip), dimension(:), allocatable :: ics
        !> Observation counter (index of current time)
        integer(ip) :: iobs = 0
        !> Times
        real(rp), dimension(:), allocatable :: t
        !> Offset in observations/estimations arrays
        integer(ip) :: offset
        !> Observed values, sizes: dim1=2 (heights and widths), dim2=size(t)
        real(rp), dimension(:, :), allocatable :: obs
        !> Weights, sizes: dim1=2 (heights and widths), dim2=size(t)
        real(rp), dimension(:, :), allocatable :: w
   
    end type
    
    
    type Observations
   
        type(ObsStation), dimension(:), allocatable :: stations
        !> Observed values, sizes: dim1=2 (heights and widths), dim2=N (all stations & all times)
        real(rp), dimension(:, :), allocatable :: obs
        !> Weights, sizes: dim1=2 (heights and widths), dim2=N (all stations & all times)
        real(rp), dimension(:, :), allocatable :: w
        !> Estimated values, sizes: dim1=2 (heights and widths), dim2=N (all stations & all times)
        real(rp), dimension(:, :), allocatable :: est
   
    end type
    
    
    contains
#ifndef CPP_ADJ
    
    
    subroutine obsstation_initialise(station, ics, t, values)
        implicit none
        integer(ip), dimension(:), intent(in) :: ics
        real(rp), dimension(:), intent(in) :: t
        real(rp), dimension(:, :), intent(in) :: values
        type(ObsStation), intent(out) :: station
        
        ! Check sizes
        if (size(t) /= size(values, 2)) then
            call f90wrap_abort("shape(values, 2) must be equal to size(t)")
        end if
        if (size(values, 1) /= 2) then
            call f90wrap_abort("shape(values, 1) must be equal to 2 (heights and widths)")
        end if
        
        allocate(station%ics(size(ics)))
        station%ics(:) = ics(:)
        allocate(station%t(size(t)))
        station%t(:) = t(:)
        station%offset = -1
        allocate(station%obs(2, size(t)))
        station%obs(:, :) = values(:, :)
        
    end subroutine obsstation_initialise
    
    
    subroutine obsstation_finalise(station)
        implicit none
        type(ObsStation), intent(inout) :: station
        
        ! Check sizes
        if (allocated(station%ics)) deallocate(station%ics)
        if (allocated(station%t)) deallocate(station%t)
        if (allocated(station%obs)) deallocate(station%obs)
        
    end subroutine obsstation_finalise
    
    
    subroutine setup_station_using_indices(station, msh, ics, t, values)
        implicit none
        type(ObsStation), intent(inout) :: station
        type(Mesh), intent(in) :: msh
        integer(ip), dimension(:), intent(in) :: ics
        real(rp), dimension(:), intent(in) :: t
        real(rp), dimension(:, :), intent(in), optional :: values
        
        ! Iterators
        integer(ip) :: i1, i2
        
        ! Check sizes
        if (present(values)) then
            if (size(t) /= size(values, 2)) then
                print *, "size(values) =", size(values, 1), size(values, 2)
                call f90wrap_abort("shape(values, 2) must be equal to size(t)")
            end if
            if (size(values, 1) /= 2) then
                call f90wrap_abort("shape(values, 1) must be equal to 2 (heights and widths)")
            end if
        end if
        
        if (allocated(station%ics)) deallocate(station%ics)
        if (allocated(station%t)) deallocate(station%t)
        if (allocated(station%obs)) deallocate(station%obs)
        
        allocate(station%ics(size(ics)))
        station%ics(:) = -1
        do i1 = 1, msh%ncs
            do i2 = 1, size(ics)
                if (msh%cs(i1)%ibase == ics(i2)) then
                    station%ics(i2) = i1
                end if
            end do
        end do
        
        ! Check all cross-sections found in mesh
        do i1 = 1, size(ics)
            if (station%ics(i1) < 1) then
                call f90wrap_abort("some cross-sections cannot be found in mesh")
            end if
        end do
        
        allocate(station%t(size(t)))
        station%t(:) = t(:)
        station%offset = -1
        if (present(values)) then
            allocate(station%obs(2, size(t)))
            station%obs(:, :) = values(:, :)
            allocate(station%w(2, size(t)))
            station%w(:, :) = 1.0
!             print *, "setup_stations:", ics, values
        end if
        
    end subroutine setup_station_using_indices
    
    
    subroutine setup_station_using_coords(station, msh, coords, t, values)
        implicit none
        type(ObsStation), intent(inout) :: station
        type(Mesh), intent(in) :: msh
        real(rp), dimension(:, :), intent(in) :: coords
        real(rp), dimension(:), intent(in) :: t
        real(rp), dimension(:, :), intent(in), optional :: values
        
        ! Iterators
        integer(ip) :: i1, i2
        integer(ip), dimension(:), allocatable :: mindistindex
        real(rp) :: dist
        real(rp), dimension(:), allocatable :: mindist
        
        ! Check sizes
        if (size(coords, 1) /= 2) then
            call f90wrap_abort("shape(coords, 1) must be 2")
        end if
        if (present(values)) then
            if (size(t) /= size(values, 2)) then
                call f90wrap_abort("shape(values, 2) must be equal to size(t)")
            end if
            if (size(values, 1) /= 2) then
                call f90wrap_abort("shape(values, 1) must be equal to 2 (heights and widths)")
            end if
        end if
        
        if (allocated(station%ics)) deallocate(station%ics)
        if (allocated(station%t)) deallocate(station%t)
        if (allocated(station%obs)) deallocate(station%obs)
        
        allocate(mindist(size(coords, 2)))
        allocate(mindistindex(size(coords, 2)))
        do i1 = 1, msh%ncs
            do i2 = 1, size(coords, 2)
                dist = sqrt((coords(1, i2) - msh%cs(i1)%coord%x)**2 + &
                            (coords(2, i2) - msh%cs(i1)%coord%y)**2)
                if (i1 == 1) then
                    mindist(i2) = dist
                    mindistindex(i2) = i1
                else if (dist < mindist(i2)) then
                    mindist(i2) = dist
                    mindistindex(i2) = i1
                end if
            end do
        end do
        allocate(station%ics(size(coords, 2)))
        station%ics(:) = -1
        do i1 = 1, size(coords, 2)
            station%ics(i1) = mindistindex(i1)
        end do
        
        allocate(station%t(size(t)))
        station%t(:) = t(:)
        station%offset = -1
        if (present(values)) then
            allocate(station%obs(2, size(t)))
            station%obs(:, :) = values(:, :)
            allocate(station%w(2, size(t)))
            station%w(:, :) = 1.0
!             print *, "setup_stations:", ics, values
        end if
        
    end subroutine setup_station_using_coords
    
    
    subroutine setup_station_using_coords_and_segment(station, msh, iseg, coords, t, values)
        implicit none
        type(ObsStation), intent(inout) :: station
        type(Mesh), intent(in) :: msh
        integer(ip), intent(in) :: iseg
        real(rp), dimension(:, :), intent(in) :: coords
        real(rp), dimension(:), intent(in) :: t
        real(rp), dimension(:, :), intent(in), optional :: values
        
        ! Iterators
        integer(ip) :: i1, i2
        integer(ip), dimension(:), allocatable :: mindistindex
        real(rp) :: dist
        real(rp), dimension(:), allocatable :: mindist
        
        ! Check sizes
        if (size(coords, 1) /= 2) then
            call f90wrap_abort("shape(coords, 1) must be 2")
        end if
        if (present(values)) then
            if (size(t) /= size(values, 2)) then
                call f90wrap_abort("shape(values, 2) must be equal to size(t)")
            end if
            if (size(values, 1) /= 2) then
                call f90wrap_abort("shape(values, 1) must be equal to 2 (heights and widths)")
            end if
        end if
        
        if (allocated(station%ics)) deallocate(station%ics)
        if (allocated(station%t)) deallocate(station%t)
        if (allocated(station%obs)) deallocate(station%obs)
        
        allocate(mindist(size(coords, 2)))
        allocate(mindistindex(size(coords, 2)))
        do i1 = msh%seg(iseg+1)%first_cs, msh%seg(iseg+1)%last_cs
            do i2 = 1, size(coords, 2)
!                 if (i1 == msh%seg(iseg+1)%last_cs) then
!                     print *, "COORDS:", coords(1, i2), coords(2, i2)
!                 end if
                dist = sqrt((coords(1, i2) - msh%cs(i1)%coord%x)**2 + &
                            (coords(2, i2) - msh%cs(i1)%coord%y)**2)
                if (i1 == msh%seg(iseg+1)%first_cs) then
                    mindist(i2) = dist
                    mindistindex(i2) = i1
                else if (dist < mindist(i2)) then
                    mindist(i2) = dist
                    mindistindex(i2) = i1
                end if
            end do
        end do
        allocate(station%ics(size(coords, 2)))
        station%ics(:) = -1
        do i1 = 1, size(coords, 2)
            station%ics(i1) = mindistindex(i1)
        end do
        
        allocate(station%t(size(t)))
        station%t(:) = t(:)
        station%offset = -1
        if (present(values)) then
            allocate(station%obs(2, size(t)))
            station%obs(:, :) = values(:, :)
            allocate(station%w(2, size(t)))
            station%w(:, :) = 1.0
!             print *, "setup_stations:", ics, values
        end if
        
    end subroutine setup_station_using_coords_and_segment
    
    
    subroutine setup_station_using_abscissa(station, msh, x, t, values)
        implicit none
        type(ObsStation), intent(inout) :: station
        type(Mesh), intent(in) :: msh
        real(rp), dimension(:), intent(in) :: x
        real(rp), dimension(:), intent(in) :: t
        real(rp), dimension(:, :), intent(in), optional :: values
        
        ! Iterators
        integer(ip) :: i1, i2
        integer(ip), dimension(:), allocatable :: mindistindex
        real(rp) :: dist
        real(rp), dimension(:), allocatable :: mindist
        
        ! Check sizes
        if (present(values)) then
            if (size(t) /= size(values, 2)) then
                print *, "size(values) =", size(values, 1), size(values, 2)
                call f90wrap_abort("shape(values, 2) must be equal to size(t)")
            end if
            if (size(values, 1) /= 2) then
                call f90wrap_abort("shape(values, 1) must be equal to 2 (heights and widths)")
            end if
        end if
        
        if (allocated(station%ics)) deallocate(station%ics)
        if (allocated(station%t)) deallocate(station%t)
        if (allocated(station%obs)) deallocate(station%obs)
        
        allocate(mindist(size(x)))
        allocate(mindistindex(size(x)))
        do i1 = 1, msh%ncs
            do i2 = 1, size(x)
                dist = abs((x(i2) - msh%cs(i1)%x))
                ! if (i2 == 1) then
                !     print *, i1, dist
                ! end if
                if (i1 == 1) then
                    mindist(i2) = dist
                    mindistindex(i2) = i1
                else if (dist < mindist(i2)) then
                    mindist(i2) = dist
                    mindistindex(i2) = i1
                end if
            end do
        end do
        allocate(station%ics(size(x)))
        station%ics(:) = -1
        do i1 = 1, size(x)
            ! print *, "mindistindex=", mindistindex(i1)
            station%ics(i1) = mindistindex(i1)
        end do
        
        allocate(station%t(size(t)))
        station%t(:) = t(:)
        station%offset = -1
        if (present(values)) then
            allocate(station%obs(2, size(t)))
            station%obs(:, :) = values(:, :)
            allocate(station%w(2, size(t)))
            station%w(:, :) = 1.0
!             print *, "setup_stations:", ics, values
        end if
        
    end subroutine setup_station_using_abscissa
    
    
    subroutine setup_station_using_abscissa_and_segment(station, msh, iseg, x, t, values)
        implicit none
        type(ObsStation), intent(inout) :: station
        type(Mesh), intent(in) :: msh
        integer(ip), intent(in) :: iseg
        real(rp), dimension(:), intent(in) :: x
        real(rp), dimension(:), intent(in) :: t
        real(rp), dimension(:, :), intent(in), optional :: values
        
        ! Iterators
        integer(ip) :: i1, i2
        integer(ip), dimension(:), allocatable :: mindistindex
        real(rp) :: dist
        real(rp), dimension(:), allocatable :: mindist
        
        ! Check sizes
        if (present(values)) then
            if (size(t) /= size(values, 2)) then
                print *, "size(values) =", size(values, 1), size(values, 2)
                call f90wrap_abort("shape(values, 2) must be equal to size(t)")
            end if
            if (size(values, 1) /= 2) then
                call f90wrap_abort("shape(values, 1) must be equal to 2 (heights and widths)")
            end if
        end if
        
        if (allocated(station%ics)) deallocate(station%ics)
        if (allocated(station%t)) deallocate(station%t)
        if (allocated(station%obs)) deallocate(station%obs)
        
        allocate(mindist(size(x)))
        allocate(mindistindex(size(x)))
        do i1 = msh%seg(iseg+1)%first_cs, msh%seg(iseg+1)%last_cs
            do i2 = 1, size(x)
                dist = abs((x(i2) - msh%cs(i1)%x))
                ! if (i2 == 1) then
                !     print *, i1, x(i2), msh%cs(i1)%x, dist
                ! end if
                if (i1 == msh%seg(iseg+1)%first_cs) then
                    mindist(i2) = dist
                    mindistindex(i2) = i1
                else if (dist < mindist(i2)) then
                    mindist(i2) = dist
                    mindistindex(i2) = i1
                end if
            end do
        end do
        allocate(station%ics(size(x)))
        station%ics(:) = -1
        do i1 = 1, size(x)
            ! print *, "mindistindex=", mindistindex(i1)
            station%ics(i1) = mindistindex(i1)
        end do
        
        allocate(station%t(size(t)))
        station%t(:) = t(:)
        station%offset = -1
        if (present(values)) then
            allocate(station%obs(2, size(t)))
            station%obs(:, :) = values(:, :)
            allocate(station%w(2, size(t)))
            station%w(:, :) = 1.0
!             print *, "setup_stations:", ics, values
        end if
        
    end subroutine setup_station_using_abscissa_and_segment
    
    
    subroutine set_station_weights(station, weights)
        implicit none
        type(ObsStation), intent(inout) :: station
        real(rp), dimension(:, :), intent(in) :: weights
        
        ! Check sizes
        if (size(weights, 1) /= size(station%obs, 1)) then
            call f90wrap_abort("shape(weights, 1) must be equal to shape(station%values, 1)")
        end if
        if (size(weights, 2) /= size(station%obs, 2)) then
            call f90wrap_abort("shape(weights, 2) must be equal to shape(station%values, 2)")
        end if
        
        if (allocated(station%w)) deallocate(station%w)
        
        allocate(station%w(size(weights, 1), size(weights, 2)))
        station%w(:, :) = weights(:, :)
        
    end subroutine set_station_weights
    
    
    subroutine observations_initialise(obs, nstations)
        implicit none
        integer(ip), intent(in) :: nstations
        type(Observations), intent(out) :: obs
        
        allocate(obs%stations(nstations))
        
    end subroutine observations_initialise
    
    
    subroutine observations_finalise(obs)
        implicit none
        type(Observations), intent(inout) :: obs
        
        ! Check sizes
        if (allocated(obs%stations)) deallocate(obs%stations)
        if (allocated(obs%obs)) deallocate(obs%obs)
        if (allocated(obs%est)) deallocate(obs%est)
        
    end subroutine observations_finalise
    
    
    subroutine setup_observations_data(obs, ndata)
        implicit none
        type(Observations), intent(inout) :: obs
        integer(ip), intent(in) :: ndata
        
        if (allocated(obs%obs)) deallocate(obs%obs)
        if (allocated(obs%est)) deallocate(obs%est)
        if (allocated(obs%w)) deallocate(obs%w)
        allocate(obs%obs(2, ndata))
        allocate(obs%est(2, ndata))
        allocate(obs%w(2, ndata))
        obs%obs(:, :) = -1e+99_rp
        obs%est(:, :) = -1e+99_rp
        obs%w(:, :) = 1.0_rp
        
    end subroutine setup_observations_data
    
    
    subroutine all_observed(t, msh, obs)
        implicit none
        type(Mesh), intent(in) :: msh
        real(rp), dimension(:), intent(in) :: t
        type(Observations), intent(out) :: obs
        
        ! Index of cross-section
        integer(ip) :: ics
        ! Index of segment
        integer(ip) :: iseg
        ! Index of station
        integer(ip) :: ista
        ! Number of observations/estimations data
        integer(ip) :: ndata
        ! Number of stations
        integer(ip) :: nsta
        
        ! Compute number of stations (number of interior cross-sections)
        nsta = 0
        do iseg = 1, msh%nseg
            do ics = msh%seg(iseg)%first_cs, msh%seg(iseg)%last_cs
                if (msh%cs(ics)%ibase > 0) then
                    nsta = nsta + 1
                end if
            end do
        end do
        
        allocate(obs%stations(nsta))

        ! Create stations
        ista = 1
        do iseg = 1, msh%nseg
            do ics = msh%seg(iseg)%first_cs, msh%seg(iseg)%last_cs
                if (msh%cs(ics)%ibase > 0) then
                
                    ! Allocate arrays
                    allocate(obs%stations(ista)%ics(1))
                    allocate(obs%stations(ista)%t(size(t)))
                    
                    ! Set index of cross-section for current station
                    obs%stations(ista)%ics(1) = ics
                    
                    ! Set times
                    obs%stations(ista)%t(:) = t(:)
                    
                    ! Set offset
                    obs%stations(ista)%offset = (ista - 1) * size(t)
                    
                    ! Set empty array for obs
                    allocate(obs%stations(ista)%obs(0, 0))
                    
                    ista = ista + 1
                    
                end if
            end do
        end do
        
        ! Initialise observations and estimations arrays
        ndata = nsta * size(t)
        allocate(obs%obs(2, ndata))
        allocate(obs%est(2, ndata))
        allocate(obs%w(2, ndata))
        obs%obs(:, :) = -1e+99_rp
        obs%est(:, :) = -1e+99_rp
        obs%w(:, :) = 1.0_rp
        
    end subroutine all_observed
    
    
    subroutine data_from_stations(obs, discharge_estimation)
        implicit none
        type(Observations), intent(inout) :: obs
        logical, intent(in), optional :: discharge_estimation
        
        logical :: use_weights
        ! Index of data
        integer(ip) :: idata
        ! Index of station
        integer(ip) :: ista
        ! Number of observations/estimations data
        integer(ip) :: ndata
        ! Number of stations
        integer(ip) :: nsta
        
        ! Count number of data and set offsets
        ndata = 0
        use_weights = .false.
        do ista = 1, size(obs%stations)
            obs%stations(ista)%offset = ndata
            ndata = ndata + size(obs%stations(ista)%t)
            if (allocated(obs%stations(ista)%w)) then
                use_weights = .true.
            end if
        end do
!         print *, "NDATA=", ndata
        
        ! Setup observations and estimations arrays
        if (allocated(obs%obs)) deallocate(obs%obs)
        if (allocated(obs%w)) deallocate(obs%w)
        if (allocated(obs%est)) deallocate(obs%est)
        
        allocate(obs%obs(2, ndata))
        allocate(obs%w(2, ndata))
        if (present(discharge_estimation)) then
            if (discharge_estimation) then
                allocate(obs%est(3, ndata))
            else
                allocate(obs%est(2, ndata))
            end if
        else
            allocate(obs%est(2, ndata))
        end if
!         allocate(obs%est(2, ndata))
        idata = 0
        do ista = 1, size(obs%stations)
!             print *, "STATION=", ista
            ndata = size(obs%stations(ista)%obs, 2)
            if (allocated(obs%stations(ista)%obs)) then
                obs%obs(:, idata+1:idata+ndata) = obs%stations(ista)%obs(:, :)
            else
                obs%obs(:, idata+1:idata+ndata) = -1e+99_rp
            end if
            if (use_weights) then
                if (.not. allocated(obs%stations(ista)%w)) then
                    call abort_solver("Station has no weight set")
                end if
                obs%w(:, idata+1:idata+ndata) = obs%stations(ista)%w(:, :)
            else
                obs%w(:, idata+1:idata+ndata) = 1.0_rp
            end if
            idata = idata + ndata
        end do
        obs%est(:, :) = -1e+99_rp
        
    end subroutine data_from_stations
!         
!     
!     subroutine get_all_observed_heights(obs, heights)
!         implicit none
!         type(Observations), intent(in) :: obs
!         real(rp), dimension(:), allocatable, intent(out) :: heights
!         
!         ! Iterator
!         integer(ip) :: i
!         ! Index of data
!         integer(ip) :: idata
!         ! Index of station
!         integer(ip) :: ista
!         ! Number of data
!         integer(ip) :: ndata
!         
!         ! Compute number of data
!         ndata = 0
!         do ista = 1, size(obs%stations)
!             ndata = ndata + size(obs%stations(ista)%t)
!         end do
! 
!         ! Create data array
!         allocate(heights(ndata))
!         idata = 1
!         do ista = 1, size(obs%stations)
!             do i = 1, size(obs%stations(ista)%t)
!                 heights(idata) = obs%stations(ista)%obs(1, i)
!                 idata = idata + 1
!             end do
!         end do
!         
!     end subroutine get_all_observed_heights
! 
!     
!     subroutine get_all_estimated_heights(obs, heights)
!         implicit none
!         type(Observations), intent(in) :: obs
!         real(rp), dimension(:), allocatable, intent(out) :: heights
!         
!         ! Iterator
!         integer(ip) :: i
!         ! Index of data
!         integer(ip) :: idata
!         ! Index of station
!         integer(ip) :: ista
!         ! Number of data
!         integer(ip) :: ndata
!         
!         ! Compute number of data
!         ndata = 0
!         do ista = 1, size(obs%stations)
!             ndata = ndata + size(obs%stations(ista)%t)
!         end do
! 
!         ! Create data array
!         allocate(heights(ndata))
!         idata = 1
!         do ista = 1, size(obs%stations)
!             do i = 1, size(obs%stations(ista)%t)
!                 heights(idata) = obs%stations(ista)%est(1, i)
!                 idata = idata + 1
!             end do
!         end do
!         
!     end subroutine get_all_estimated_heights


    subroutine write_observations_status(obs)
        implicit none
        type(Observations), intent(in) :: obs
        
        ! Iterators
        integer(ip) :: i
        ! Index of observation
        integer(ip) :: iobs
        ! Index of station
        integer(ip) :: ista
        ! Index of observation variable
        integer(ip) :: ivar
        ! Temporary strings
        character(len=32) :: tmp
        
        open(10, file="out/observations_status.dat")
        
        do ista = 1, size(obs%stations)
        
            write(tmp, '(I32)') ista
            write(10, '(2A)') "STATION ", trim(adjustl(tmp))
            write(10, '(A)') "t;H;W"
            
            do i = 1, size(obs%stations(ista)%t)
            
                iobs = i + obs%stations(ista)%offset
                
                write(tmp, '(F32.6)') obs%stations(ista)%t(i)
                write(10, '(A)', advance='no') trim(adjustl(tmp))
                
                do ivar = 1, 2
                
                    if (obs%obs(1, iobs) > -999.0) then
                        if (obs%est(1, iobs) > -999.0) then
                            write(10, '(A)', advance='no') ";V"
                        else
                            write(10, '(A)', advance='no') ";X"
                        end if
                    else
                        write(10, '(A)', advance='no') ";NA"
                    end if
                    
                end do
                write(10, *)
                
            end do
        end do
        
    end subroutine write_observations_status

    
    
    function extract_window_obs(obs, ts, te) result(window_obs)
        implicit none
        type(Observations), intent(inout) :: obs
        real(rp), intent(in) :: ts
        real(rp), intent(in) :: te
        type(Observations) :: window_obs
        
        ! Index of data
        integer(ip) :: idata
        ! Index of observation
        integer(ip) :: iobs
        ! Index of station
        integer(ip) :: ista
        ! Number of data
        integer(ip) :: ndata
        
        ! Allocate stations
        allocate(window_obs%stations(size(obs%stations)))
        
        do ista = 1, size(obs%stations)
            
            ! Count number of data on window
            ndata = 0
            do iobs = 1, size(obs%stations(ista)%t)
                if (obs%stations(ista)%t(iobs) >= ts .and. obs%stations(ista)%t(iobs) <= te) ndata = ndata + 1
            end do
            
            ! Store data
            allocate(window_obs%stations(ista)%t(ndata))
            allocate(window_obs%stations(ista)%obs(2, ndata))
            if (allocated(obs%stations(ista)%w)) allocate(window_obs%stations(ista)%w(2, ndata))
            idata = 0
            do iobs = 1, size(obs%stations(ista)%t)
                if (obs%stations(ista)%t(iobs) >= ts .and. obs%stations(ista)%t(iobs) <= te) then
                    idata = idata + 1
                    window_obs%stations(ista)%t(idata) = obs%stations(ista)%t(iobs)
                    window_obs%stations(ista)%obs(:, idata) = obs%stations(ista)%obs(:, iobs)
                    if (allocated(obs%stations(ista)%w)) then
                        window_obs%stations(ista)%w(:, idata) = obs%stations(ista)%w(:, iobs)
                    end if
                end if
            end do
        end do
        
    end function extract_window_obs
#endif   
    
    
    subroutine reset_observations_counters(obs)
        implicit none
        type(Observations), intent(inout) :: obs
        
        ! Index of station
        integer(ip) :: ista
        
        do ista = 1, size(obs%stations)
            obs%stations(ista)%iobs = 1
        end do
        
    end subroutine reset_observations_counters
    
    
    function cost_L2_heights(Hest, Hobs) result(cost)
#ifndef CPP_ADJ
        use m_common, only: disable_warnings
#endif
        implicit none
        real(rp), dimension(:), intent(in) :: Hest
        real(rp), dimension(:), intent(in) :: Hobs
        real(rp) :: cost
        
        ! Index of observation
        integer(ip) :: iobs
#ifndef CPP_ADJ
        ! Number of observations skipped (no estimation)
        integer(ip) :: skipped
        ! Temporary strings
        character(len=32), dimension(2) :: tmp
#endif

        cost = 0.0
#ifndef CPP_ADJ
        skipped = 0
#endif
        do iobs = 1, size(Hest)
            if (Hobs(iobs) > -999.0) then
                if (Hest(iobs) > -999.0) then
                    cost = cost + (Hest(iobs) - Hobs(iobs))**2
#ifndef CPP_ADJ
                else
                    skipped = skipped + 1
#endif
                end if
            end if
        end do
#ifndef CPP_ADJ
!         cost = sqrt(cost**2)
        if (skipped > 0 .and. (.not. disable_warnings)) then
            write(tmp(1), '(I32)') skipped
            write(tmp(2), '(F32.2)') skipped * 100.0 / size(Hobs)
            print '(5A)', "[ WARNING ] ", trim(adjustl(tmp(1))), " (" , trim(adjustl(tmp(2))), &
                          " %) observations skipped (no estimation)"
        end if
#endif
        
    end function cost_L2_heights
    
    
    function cost_R2_heights(Hest, Hobs, wobs) result(cost)
#ifndef CPP_ADJ
        use m_common, only: disable_warnings
#endif
        implicit none
        real(rp), dimension(:), intent(in) :: Hest
        real(rp), dimension(:), intent(in) :: Hobs
        real(rp), dimension(:), intent(in) :: wobs
        real(rp) :: cost
        
        ! Index of observation
        integer(ip) :: iobs
#ifndef CPP_ADJ
        ! Number of observations skipped (no estimation)
        integer(ip) :: skipped
        ! Temporary strings
        character(len=32), dimension(2) :: tmp
#endif
        
        cost = 0.0
#ifndef CPP_ADJ
        skipped = 0
#endif
        do iobs = 1, size(Hest)
            if (Hobs(iobs) > -999.0) then
                if (Hest(iobs) > -999.0) then
                    cost = cost + (wobs(iobs) * (Hest(iobs) - Hobs(iobs)))**2
#ifndef CPP_ADJ
                else
                    skipped = skipped + 1
#endif
                end if
            end if
        end do
#ifndef CPP_ADJ
!         cost = sqrt(cost**2)
        if (skipped > 0 .and. (.not. disable_warnings)) then
            write(tmp(1), '(I32)') skipped
            write(tmp(2), '(F32.2)') skipped * 100.0 / size(Hobs)
            print '(5A)', "[ WARNING ] ", trim(adjustl(tmp(1))), " (" , trim(adjustl(tmp(2))), &
                          " %) observations skipped (no estimation)"
        end if
#endif

    end function cost_R2_heights

end module m_obs
