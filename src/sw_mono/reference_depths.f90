!======================================================================================================================!
!
!                    DassFlow1D Version 2.1
!
!======================================================================================================================!
!
!  Copyright University of Toulouse-INSA - CNRS (France)
!
!  This file is part of the DassFlow software (Data Assimilation for Free Surface Flows).
!  DassFlow is a computational software aiming at simulating geophysical free surface flows.
!  It is designed for Variational Data Assimilation (4D-var) and sensitivity analyses. 
! Inverse capabilities are based on the adjoint code which is generated by 
! a source-to-source algorithmic differentiation (Tapenade software used).
!
!  DassFlow software includes few mostly independent "modules" with common architectures and structures:
!    - DassFlow 2DShallow (shallow water equations in (h,q), finite volumes), i.e. the present code.
!    - DassFlow3D  (non-linear Stokes equations, finite elements, mobile geometries, ALE).
!    - DassFlow 1D (shallow water equations in (S,Q), finite volumes or finite differences), river hydraulics.
!  Please consult the DassFlow webpage for more details: http://www.math.univ-toulouse.fr/DassFlow
!
! You have used DassFlow in an article, a scientific document etc ?  How to cite us ? Please consult the webpage.
! 
!  Many people have contributed to the DassFlow developments from the initial version to the latest ones.
!  Current main developers or scientific contributers are:
!               P. Brisset (CNES & Mathematics Institute of Toulouse & INSA Toulouse)
!               F. Couderc (CNRS & Mathematics Institute of Toulouse IMT)
!               P.-A. Garambois (INSA & ICUBE Strasbourg)
!               J. Monnier (INSA & Mathematics Institute of Toulouse IMT).
!               J.-P. Vila (INSA & Mathematics Institute of Toulouse IMT).
!  and former other developers (R. Madec, M. Honnorat and J. Marin).
!
!  Scientific contact : jerome.monnier@insa-toulouse.fr
!  Technical  contacts : frederic.couderc@math.univ-toulouse.fr, pierre.brisset@insa-toulouse.fr
!
!  This software is governed by the CeCILL license under French law and abiding by the rules of distribution
!  of free software. You can use, modify and/or redistribute the software under the terms of the CeCILL license
!  as circulated by CEA, CNRS and INRIA at the following URL: "http://www.cecill.info".
!
!  As a counterpart to the access to the source code and rights to copy, modify and redistribute granted by the
!  license, users are provided only with a limited warranty and the software's author, the holder of the economic
!  rights, and the successive licensors have only limited liability.
!
!  In this respect, the user's attention is drawn to the risks associated with loading, using, modifying and/or
!  developing or reproducing the software by the user in light of its specific status of free software, that may
!  mean that it is complicated to manipulate, and that also therefore means that it is reserved for developers and
!  experienced professionals having in-depth computer knowledge. Users are therefore encouraged to load and test the
!  software's suitability as regards their requirements in conditions enabling the security of their systems and/or
!  data to be ensured and, more generally, to use and operate it in the same conditions as regards security.
!
!  The fact that you are presently reading this means that you have had knowledge of the CeCILL license and that you
!  accept its terms.
!
!======================================================================================================================!
!> \file reference_depths.f90
!! \brief This file includes the computation of the normal and critical depths


!<NOADJ

! NEED TO ADAPT THE CALC OF STRICKLER COEFF 

!**********************************************************************************************************************!
!**********************************************************************************************************************!
!
!  Compute normal depth
!
!**********************************************************************************************************************!
!**********************************************************************************************************************!

!>  Compute normal depth
!!
!! \details This subroutine compute the normal depth
!! \param[in]    msh Mesh of the problem.
!! \param[in]    dof Unknowns of the model.
!!$SUBROUTINE computes_normal_depth(msh, dof)
!!$
!!$   USE m_mesh
!!$   USE m_model
!!$   USE m_numeric
!!$   USE m_user_data
!!$
!!$   implicit none
!!$
!!$!======================================================================================================================!
!!$!  Interface Variables
!!$!======================================================================================================================!
!!$
!!$   type(Mesh), intent(in   )  ::  msh
!!$   type( unk ), intent(in   )  ::  dof
!!$
!!$!======================================================================================================================!
!!$!  Local Variables
!!$!======================================================================================================================!
!!$
!!$   real(rp) :: perimeter ! Wet Perimeter 
!!$   real(rp) :: Rh        ! Hydraulic radius
!!$   real(rp) :: Manning   ! Manning
!!$   real(rp) :: debitance ! Debitance
!!$   real(rp) :: dx        ! Spatial step size
!!$   real(rp) :: S0        ! Bathy slope
!!$   real(rp) :: Sf        ! Friction slope
!!$   real(rp) :: hmin, hmax      ! min and max depth (used in the fzero routine)
!!$   real(rp) :: dh_rel, dh_abs    ! relative and absolute error convergence criterion for the fzero routine
!!$   integer(ip) :: iflag  ! flag for the fzero routine
!!$   integer(ip), dimension(msh%ncs+4) :: mvector           ! Vector m
!!$      
!!$!======================================================================================================================!
!!$!  Begin Subroutine
!!$!======================================================================================================================!
!!$   do i = 1, msh%ncs+3
!!$         
!!$      ! Compute S0, the local bed slope
!!$      dx = msh%cs(i+1)%deltademi
!!$      S0 = (bathy_cell(i) - bathy_cell(i+1)) / dx
!!$      ! if S0<0, norma depth does not exist : set hn<0 to be post-treated 
!!$      if ( S0<0 ) then
!!$         hn(i) = -1
!!$         cycle
!!$      endif
!!$      ! Find the depth h so that S0 = Sf(h)
!!$      dh_rel = 0.0001
!!$      dh_abs = 0.001
!!$      hmin = 0.001
!!$      hmax = 20
!!$      call fzero( friction_bed_slope_diff,hmin,hmax,dh_rel,dh_abs,iflag )
!!$      if (iflag > 1) then
!!$         hn(i) = -iflag
!!$         cycle
!!$      endif
!!$      hn(i) = hmin
!!$   end do
!!$
!!$   
!!$ CONTAINS
!!$   
!!$   real(rp) FUNCTION friction_bed_slope_diff( h )
!!$
!!$     implicit none
!!$     
!!$     ! Local Variables
!!$     real(rp) :: S       ! Surface corresponding to the input h
!!$     real(rp), intent(inout) :: h
!!$     ! External functions
!!$     real(rp)  :: PerimeterFromH
!!$     real(rp)  :: HtoS
!!$     integer(ip)  :: findMHeight
!!$     
!!$     ! Find trapezoidal layer corresponding to h
!!$     mvector(i) = findMHeight(msh,h,i)
!!$     ! Compute geometry for given h and current cross-section i
!!$     S = HtoS(msh, i, h)
!!$     perimeter = PerimeterFromH(msh, h, i, mvector)
!!$     Rh = S / perimeter
!!$     ! Compute Sf, the friction slope
!!$     Manning = alpha * h**beta
!!$     debitance = Manning * S * (Rh**(d2p3))
!!$     Sf = dof%q(i)**2 / debitance**2
!!$   
!!$     friction_bed_slope_diff = S0 - Sf
!!$
!!$   END FUNCTION friction_bed_slope_diff
!!$
!!$ END SUBROUTINE computes_normal_depth
!!$!>NOADJ
!!$
!!$
!!$
!!$
!!$!**********************************************************************************************************************!
!!$!**********************************************************************************************************************!
!!$!
!!$!  Computes critical depth
!!$!
!!$!**********************************************************************************************************************!
!!$!**********************************************************************************************************************!
!!$
!!$!>  Computes critical depth
!!$!!
!!$!! \details This subroutine compute the critical depth
!!$!! \param[in]    msh Mesh of the problem.
!!$!! \param[in]    dof Unknowns of the model.
!!$SUBROUTINE computes_critical_depth(msh, dof)
!!$
!!$   USE m_mesh
!!$   USE m_model
!!$   USE m_numeric
!!$   USE m_user_data
!!$
!!$   implicit none
!!$
!!$!======================================================================================================================!
!!$!  Interface Variables
!!$!======================================================================================================================!
!!$
!!$   type(Mesh), intent(in   )  ::  msh
!!$   type( unk ), intent(in   )  ::  dof
!!$
!!$!======================================================================================================================!
!!$!  Local Variables
!!$!======================================================================================================================!
!!$
!!$   real(rp) :: hmin, h                            ! min value accepted for h and first guess of critical height (in), and current critical depth given by the minimization method (out)
!!$   real(rp), dimension(:,:), allocatable :: h_tmp ! array to store the values of h to interpolate where no value for h is found
!!$   real(rp) :: err                                ! tolerance error used for the convergence criterion in the Newtons method
!!$   integer(ip) :: maxiter                         ! maximum nb of iterations allowed in the Newtons method
!!$   integer(ip) :: nb_fail                         ! nb of times the Newton method has not converged
!!$   integer(ip), dimension(:), allocatable :: i_fail_arr ! nb of cs where the Newton ethod has not converged
!!$   integer(ip) :: i_fail, i_ok, ii                ! indexes for loops
!!$   real(rp) :: w, S                               ! width and area corresponding to the input h
!!$   real(rp) :: fr2                                ! square of the Froude number
!!$   real(rp) :: dWdZ                               ! derivative of the width wrt the elevation, used to compute the gradient
!!$   ! External functions
!!$   real(rp)  :: GetWFromH
!!$   real(rp) :: dWdZFromH
!!$   real(rp) :: HtoS
!!$   
!!$!======================================================================================================================!
!!$!  Begin Subroutine
!!$   !======================================================================================================================!
!!$   nb_fail = 0
!!$   ! Parameters for Newton method
!!$   err = 1.d-3
!!$   maxiter = 100
!!$   hmin = 1e-3
!!$  
!!$   ! Loop over the msh cross-sections
!!$   do i = 1, msh%ncs+3
!!$      h = 1 ! could be outside the loop on the cross-section, but bad initialization if the Newton method fails at the previous c-s
!!$      ! NEWTON loop
!!$      do ii=1,maxiter       
!!$         ! Function to minimize
!!$         w = GetWFromH(msh, h, i)            
!!$         S = HtoS(msh, i, h)                 
!!$         fr2 = dof%q(i)**2 * w / (g * S**3)   
!!$         ! Converged ?
!!$         if (abs(1-fr2) < err) then
!!$            hc(i) = h
!!$            exit
!!$         end if
!!$         dWdZ = dWdZFromH(msh, h, i)        
!!$!          print*, 'ii=', ii, 'h=', h, 'w=', w, 'S=', S, 'Q', dof%q(i),'fr2=', fr2, 'dWdZ=', dWdZ
!!$!          print*, 'dh=', -(1-fr2)/(fr2*(3._rp*w/S - dWdZ/w))
!!$         ! Else increment h
!!$         h = max( hmin, h - (1-fr2)/(fr2*(3._rp*w/S - dWdZ/w)) )
!!$      enddo
!!$      
!!$      ! if max ite and not converged, oflag=1
!!$      w = GetWFromH(msh, h, i)            
!!$      S = HtoS(msh, i, h)                 
!!$      fr2 = dof%q(i)**2 * w / (g * S**3) 
!!$      if (ii > maxiter .and. abs(1-fr2) > err)  then
!!$         hc(i) = -1._rp
!!$         nb_fail = nb_fail + 1
!!$      else
!!$         hc(i) = h
!!$      end if
!!$   end do
!!$
!!$   ! Linear interp hc not found by Newton: negative value to show that it is an interpolation
!!$   !<NOADJ
!!$   if (nb_fail > 0) then
!!$    print *, "computes_critical_depth::nb_fail=", nb_fail, "/", msh%ncs+3
!!$   end if
!!$   !>NOADJ
!!$   allocate(h_tmp(msh%ncs+3-nb_fail,2))
!!$   allocate(i_fail_arr(nb_fail))
!!$
!!$   i_fail = 1
!!$   i_ok = 1
!!$   do i = 1, msh%ncs+3
!!$      if ( hc(i)>0 ) then
!!$         h_tmp(i_ok,1) = real(i,rp)
!!$         h_tmp(i_ok,2) = hc(i)
!!$         i_ok = i_ok + 1
!!$      else
!!$         i_fail_arr(i_fail) = i
!!$         i_fail = i_fail + 1
!!$      end if
!!$   end do
!!$   do i = 1,nb_fail
!!$      hc(i_fail_arr(i)) = -linear_interp( h_tmp(:,1) , h_tmp(:,2) ,  real(i_fail_arr(i),8))
!!$   end do
!!$   ! Deallocate
!!$   deallocate(h_tmp)
!!$   deallocate(i_fail_arr)
!!$
!!$ END SUBROUTINE computes_critical_depth
!!$



!**********************************************************************************************************************!
!**********************************************************************************************************************!
!
!  Computes critical depth at a single cross-section, using the bisection method
!
!**********************************************************************************************************************!
!**********************************************************************************************************************!

!>  Computes critical depth at a single cross-section, using the bisection method
!!
!! \details This subroutine compute the critical depth
subroutine bisect_critical_depth(msh, dof, ics, gravity, q, hc1)
    use m_mesh
    use m_sw_mono
    implicit none
    !=ARGUMENTS========================================================================================================!
    !> @param[in,out] msh Mesh of the model
    type(Mesh), intent(inout) :: msh
    !> @param[in,out] dof Unknowns of the model
    type(Unknowns), intent(inout) :: dof
    !> @param[in] ics Index of cross-section
    integer(ip), intent(in)  ::  ics
    !> @param[in] gravity Gravity constant
    real(rp), intent(in)  ::  gravity
    !> @param[in] q Discharge value
    real(rp), intent(in)  ::  q
    !> @param[out] hc1 Computed Critical depth
    real(rp), intent(out)  ::  hc1
    !=LOCAL VARIABLES==================================================================================================!
    real(rp) :: w
    real(rp) :: a
    real(rp) :: fr2
    real(rp) :: hmin
    real(rp) :: hmax
    integer(ip) :: m_max
    integer(ip) :: ite

    m_max=size(msh%cs(ics)%level_heights)
    hmin = 0.1
    hmax = msh%cs(ics)%level_heights(m_max) - msh%cs(ics)%bathy
    if (hmax < hmin + 1.0) hmax = hmin + 1.0
    
    ! Test if hc > hmax
    w = htoW_noupdate(msh%cs(ics), hmax)
    a = htoA_noupdate(msh%cs(ics), hmax)
    fr2 = q**2 * w / (gravity * a**3)
    do while (fr2 > 1.0)
    
      hmax = 2.0 * hmax
!       print *, "hmax=", hmax, fr2, ics
!       print *, "fr2-detail:", fr2, a, w, q, gravity
!       print *, "Zmax:", msh%cs(ics)%level_heights(m_max), msh%cs(ics)%bathy
!       print *, "level:", msh%cs(ics)%level, msh%cs(ics)%nlevels
!       read(*,*)
      w = htoW_noupdate(msh%cs(ics), hmax)
      a = htoA_noupdate(msh%cs(ics), hmax)
      fr2 = q**2 * w / (gravity * a**3)
    
    end do
    
    ite = 0
    
    do while (hmax - hmin > 1e-3 .and. ite < 1000)
    
        ite = ite + 1
    
        hc1 = 0.5 * (hmin + hmax)
        
        w = htoW_noupdate(msh%cs(ics), hc1)
        a = htoA_noupdate(msh%cs(ics), hc1)
        fr2 = q**2 * w / (gravity * a**3)
        if (1.0 - fr2 > 0._rp) then
          hmax = hc1
        else
          hmin = hc1
        end if
        
    end do

 end subroutine bisect_critical_depth
