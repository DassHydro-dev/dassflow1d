!======================================================================================================================!
!
!                    DassFlow Version 2.0
!
!======================================================================================================================!
!
!  Copyright University of Toulouse-INSA - CNRS (France)
!
!  This file is part of the DassFlow software (Data Assimilation for Free Surface Flows).
!  DassFlow is a computational software aiming at simulating geophysical free surface flows.
!  It is designed for Variational Data Assimilation (4D-var) and sensitivity analyses. 
! Inverse capabilities are based on the adjoint code which is generated by 
! a source-to-source algorithmic differentiation (Tapenade software used).
!
!  DassFlow software includes few mostly independent "modules" with common architectures and structures:
!    - DassFlow 2DShallow (shallow water equations in (h,q), finite volumes), i.e. the present code.
!    - DassFlow3D  (non-linear Stokes equations, finite elements, mobile geometries, ALE).
!    - DassFlow 1D (shallow water equations in (S,Q), finite volumes or finite differences), river hydraulics.
!  Please consult the DassFlow webpage for more details: http://www.math.univ-toulouse.fr/DassFlow
!
! You have used DassFlow in an article, a scientific document etc ?  How to cite us ? Please consult the webpage.
! 
!  Many people have contributed to the DassFlow developments from the initial version to the latest ones.
!  Current main developers or scientific contributers are:
!               P. Brisset (CNES & Mathematics Institute of Toulouse & INSA Toulouse)
!               F. Couderc (CNRS & Mathematics Institute of Toulouse IMT)
!               P.-A. Garambois (INSA & ICUBE Strasbourg)
!               J. Monnier (INSA & Mathematics Institute of Toulouse IMT).
!               J.-P. Vila (INSA & Mathematics Institute of Toulouse IMT).
!  and former other developers (R. Madec, M. Honnorat and J. Marin).
!
!  Scientific contact : jerome.monnier@insa-toulouse.fr
!  Technical  contacts : frederic.couderc@math.univ-toulouse.fr, pierre.brisset@insa-toulouse.fr
!
!  This software is governed by the CeCILL license under French law and abiding by the rules of distribution
!  of free software. You can use, modify and/or redistribute the software under the terms of the CeCILL license
!  as circulated by CEA, CNRS and INRIA at the following URL: "http://www.cecill.info".
!
!  As a counterpart to the access to the source code and rights to copy, modify and redistribute granted by the
!  license, users are provided only with a limited warranty and the software's author, the holder of the economic
!  rights, and the successive licensors have only limited liability.
!
!  In this respect, the user's attention is drawn to the risks associated with loading, using, modifying and/or
!  developing or reproducing the software by the user in light of its specific status of free software, that may
!  mean that it is complicated to manipulate, and that also therefore means that it is reserved for developers and
!  experienced professionals having in-depth computer knowledge. Users are therefore encouraged to load and test the
!  software's suitability as regards their requirements in conditions enabling the security of their systems and/or
!  data to be ensured and, more generally, to use and operate it in the same conditions as regards security.
!
!  The fact that you are presently reading this means that you have had knowledge of the CeCILL license and that you
!  accept its terms.
!
!======================================================================================================================!
!> \file output_sw.f90
!! \brief This file includes routines of creation of ouput results file.

! #define WITH_FORCE_GRADIENTS_OUTPUT
!#define WRITE_RAWBIN

!**********************************************************************************************************************!
!**********************************************************************************************************************!
!
!  Main Subroutine Managing Output Files
!
!**********************************************************************************************************************!
!**********************************************************************************************************************!

!> \brief Initialise results file
subroutine init_results(mdl)
    use m_sw_mono, only: Model
    use m_sw_mono, only: Unknowns
    implicit none
    !=ARGUMENTS========================================================================================================!
    !> @param mdl Model
    TYPE(Model), intent(inout) :: mdl
    
    open(10, file=trim(adjustl(mdl%output_file)), status="replace")
    write(10, '(A)') "t;segment;xs;x;y;b;H;W;Q;U;A;P;S"
    close(10)
    
end subroutine

!> \brief Append results in file
subroutine write_results(mdl, iout)
    use m_common
    use m_sw_mono, only: Model
    use m_mesh, only: htoW_noupdate, htoP_noupdate
    implicit none
    !=ARGUMENTS========================================================================================================!
    !> @param mdl Model
    TYPE(Model), intent(inout) :: mdl
    !> Index of result
    integer(ip), intent(in) :: iout
    !=LOCAL VARIABLES==================================================================================================!
    ! Index of cross-section
    integer(ip) :: ics
    ! Index of segment
    integer(ip) :: iseg
    ! height difference
    real(rp) :: dH
    ! distance
    real(rp) :: dx
    ! Slope
    real(rp) :: slope
    ! Temporary string
    character(len=32) :: tmp
    
    open(10, file=trim(adjustl(mdl%output_file)), access="append")
    do iseg = 1, mdl%msh%nseg
        do ics = mdl%msh%seg(iseg)%first_cs, mdl%msh%seg(iseg)%last_cs
            if (mdl%msh%cs(ics)%ibase > 0 .or. mdl%output_resampled_cs) then
            
                ! Compute slope
                if (ics == mdl%msh%seg(iseg)%first_cs) then
                    dH = mdl%msh%cs(ics)%bathy + mdl%dof%h(ics) - (mdl%msh%cs(ics+1)%bathy + mdl%dof%h(ics+1))
                    dx = mdl%msh%cs(ics)%x - mdl%msh%cs(ics+1)%x
                else if (ics == mdl%msh%seg(iseg)%last_cs) then
                    dH = mdl%msh%cs(ics-1)%bathy + mdl%dof%h(ics-1) - (mdl%msh%cs(ics)%bathy + mdl%dof%h(ics))
                    dx = mdl%msh%cs(ics-1)%x - mdl%msh%cs(ics)%x
                else
                    dH = mdl%msh%cs(ics-1)%bathy + mdl%dof%h(ics-1) - (mdl%msh%cs(ics+1)%bathy + mdl%dof%h(ics+1))
                    dx = mdl%msh%cs(ics-1)%x - mdl%msh%cs(ics+1)%x
                end if
                slope = dH / dx 
            
                write(tmp, '(E19.12)') mdl%res%t(iout)
                write(10, '(A,";")', advance='no') trim(adjustl(tmp))
                write(tmp, '(I12)') iseg
                write(10, '(A,";")', advance='no') trim(adjustl(tmp))
                write(tmp, '(E25.18)') mdl%msh%cs(ics)%x
                write(10, '(A,";")', advance='no') trim(adjustl(tmp))
                write(tmp, '(E15.8)') mdl%msh%cs(ics)%coord%x
                write(10, '(A,";")', advance='no') trim(adjustl(tmp))
                write(tmp, '(E15.8)') mdl%msh%cs(ics)%coord%y
                write(10, '(A,";")', advance='no') trim(adjustl(tmp))
                write(tmp, '(E18.11)') mdl%msh%cs(ics)%bathy
                write(10, '(A,";")', advance='no') trim(adjustl(tmp))
                write(tmp, '(E25.18)') mdl%msh%cs(ics)%bathy + mdl%dof%h(ics)
                write(10, '(A,";")', advance='no') trim(adjustl(tmp))
                write(tmp, '(E12.5)') htoW_noupdate(mdl%msh%cs(ics), mdl%dof%h(ics))
                write(10, '(A,";")', advance='no') trim(adjustl(tmp))
                write(tmp, '(E12.5)') mdl%dof%q(ics)
                write(10, '(A,";")', advance='no') trim(adjustl(tmp))
                write(tmp, '(E12.5)') mdl%dof%q(ics) / mdl%dof%a(ics)
                write(10, '(A,";")', advance='no') trim(adjustl(tmp))
                write(tmp, '(E12.5)') mdl%dof%a(ics)
                write(10, '(A, ";")', advance='no') trim(adjustl(tmp))
                write(tmp, '(E12.5)') htoP_noupdate(mdl%msh%cs(ics), mdl%dof%h(ics))
                write(10, '(A, ";")', advance='no') trim(adjustl(tmp))
                write(tmp, '(E25.18)') slope
                write(10, '(A)') trim(adjustl(tmp))
            end if
        end do
    end do
    close(10)
    
end subroutine

!----------------------------------------------------------------------------------------------------------------------!
! DEPRECATED
!----------------------------------------------------------------------------------------------------------------------!
! !>  Main subroutine managing output files
! !!
! !! \details This subroutine manages others to write result file.
! !! \param[in]    dof Unknowns of the model.
! !! \param[in]    msh Mesh of the model.
! SUBROUTINE write_results( dof , msh )
! 
!    USE m_common
!    USE m_time_screen
!    USE m_model
! 
!    implicit none
! 
!    !===================================================================================================================!
!    !  Interface Variables
!    !===================================================================================================================!
! 
!    TYPE( unk ), intent(in)  ::  dof
!    TYPE(Mesh), intent(in)  ::  msh
! 
!    !===================================================================================================================!
!    !  Testing if it is time to write a result file
!    !===================================================================================================================!
!    if ( .not. test_dt_nearest( dtw ) .and. &
!               tc > zerom                .and. &
!               abs( tc - ts ) > zerom    .and. &
!               nt /= max_nt_for_direct ) return
! 
!    !===================================================================================================================!
!    !  Output Screen
!    !===================================================================================================================!
! 
!    call Print_Screen( 'result' )
! 
!    !===================================================================================================================!
!    !  Writing Result File
!    !===================================================================================================================!
! 
! !    call system('mkdir -p res')
!    call write_result_file( dof , msh , 'res/result' )
! 
!    call write_restart_direct( dof , msh )
! 
!    !===================================================================================================================!
!    !  Writing Exact Solution
!    !===================================================================================================================!
! 
! ! #ifdef USE_VALID
!    if      ( w_exact == 1 ) then
! 
!       call write_exact_solution( msh )
! 
!    else if ( w_exact == 2 .and. nt == 0 ) then
! 
!       call write_exact_solution( msh )
! 
!    end if
! ! #endif
!    
! #ifdef USE_REF_HEIGHT
!    call write_ref_height_file(dof, msh, 'res/ref_heights')
! #endif
! 
!  END SUBROUTINE write_results
!  
! 
! !>  Main subroutine managing output files
! !!
! !! \details This subroutine manages others to write result file (use to stationnary computation).
! !! \param[in]    dof Unknowns of the model.
! !! \param[in]    msh Mesh of the model.
! SUBROUTINE write_results_temp( dof , msh )
! 
!    USE m_common
!    USE m_time_screen
!    USE m_model
! 
!    implicit none
! 
!    !===================================================================================================================!
!    !  Interface Variables
!    !===================================================================================================================!
! 
!    TYPE( unk ), intent(in)  ::  dof
!    TYPE(Mesh), intent(in)  ::  msh
! 
! 
!    !===================================================================================================================!
!    !  Output Screen
!    !===================================================================================================================!
! 
!    call Print_Screen( 'result_bis' )
! 
!    !===================================================================================================================!
!    !  Writing Result File
!    !===================================================================================================================!
! 
!    call system('mkdir -p res')
!    call write_result_file( dof , msh , 'res/result' )
! 
!    !call write_restart_direct( dof , msh )
! 
!    !===================================================================================================================!
!    !  Writing Exact Solution
!    !===================================================================================================================!
! 
! ! #ifdef USE_VALID
!       if      ( w_exact == 1 ) then
! 
!          call write_exact_solution( msh )
! 
!       else if ( w_exact == 2 .and. nt == 0 ) then
! 
!          call write_exact_solution( msh )
! 
!       end if
! 
! ! #endif
! 
! #ifdef USE_REF_HEIGHT
!    call write_ref_height_file(dof, msh, 'res/ref_heights')
! #endif
!    
! END SUBROUTINE write_results_temp
! 
! 
! 
! !**********************************************************************************************************************!
! !**********************************************************************************************************************!
! !
! !  Main Subroutine to Write a Result File
! !
! !**********************************************************************************************************************!
! !**********************************************************************************************************************!
! 
! !>  Main subroutine to write a result file
! !!
! !! \details This subroutine writes result (unknowns \f$S\f$ and \f$Q\f$ for example) in a result file from a namefile.  
! !! \param[in]    dof Unknowns of the model.
! !! \param[in]    msh Mesh of the model.
! !! \param[in]    namefile Name of the file.
! SUBROUTINE write_result_file( dof , msh , namefile )
! 
!    USE m_common
!    USE m_time_screen
!    USE m_model
! 
!    implicit none
! 
!    !===================================================================================================================!
!    !  Interface Variables
!    !===================================================================================================================!
! 
!    TYPE( unk ), intent(in)  ::  dof
!    TYPE(Mesh), intent(in)  ::  msh
! 
!    character(len=*), intent(in)  ::  namefile
! 
!    !===================================================================================================================!
!    !  Local Variables
!    !===================================================================================================================!
! 
!    character(200)  ::  filename
!    character(150) :: tmpdir
!    logical :: dir_exists
! 
!    !===================================================================================================================!
!    !  Creating result file name
!    !===================================================================================================================!
!    call get_environment_variable("DASSFLOW1D_TMPDIR", tmpdir)
!    if (len_trim(tmpdir) > 0) then
!    
!       ! Check and create res dir if necessary
!       inquire(file=trim(tmpdir)//"/res", EXIST=dir_exists)
!       if (.not. dir_exists) then
!         print *, "mkdir "//trim(tmpdir)//"/res!!!"
!         call system('mkdir -p '//trim(tmpdir)//"/res")
!       end if
!    
!       if      ( tc < zerom ) then
!           write(filename,'(A,"/",A,"_initial")') trim(tmpdir), namefile
!       else if ( abs( tc - ts ) < zerom ) then
!           write(filename,'(A,"/",A,"_final")') trim(tmpdir), namefile
!       else
!           write(filename,'(A,"/",A,"_",ES12.6)') trim(tmpdir), namefile , tc
!       end if
!    else
!       inquire(file="res", EXIST=dir_exists)
!       if (.not. dir_exists) then
!         print *, "mkdir res!!!"
!         call system('mkdir -p res')
!       end if
!       if      ( tc < zerom ) then
!           write(filename,'(A,"_initial")') namefile
!       else if ( abs( tc - ts ) < zerom ) then
!           write(filename,'(A,"_final")') namefile
!       else
!           write(filename,'(A,"_",ES12.6)') namefile , tc
!       end if
!    end if
! 
!    !===================================================================================================================!
!    !  Gnuplot result file output
!    !===================================================================================================================!
! 
! #ifdef WRITE_RAWBIN
!    call v_rawbin( dof , msh , trim(filename)//'.bin' )
! #else
!    call v_gnuplot( dof , msh , trim(filename)//'.dat' )
! #endif
! #ifdef WITH_EXT_OUTPUT
!    call v_gnuplot_ext( dof , msh , trim(filename)//'.ext' )
! #endif
! #ifdef WITH_FORCE_GRADIENTS_OUTPUT
!    call v_gnuplot_dSf( dof , msh , trim(filename)//'.dsf' )
! !    call v_gnuplot_dF4( dof , msh , trim(filename)//'.dfi' )
! #endif
!    
! 
! END SUBROUTINE write_result_file
! 
!    
! !**********************************************************************************************************************!
! !**********************************************************************************************************************!
! !
! !  Write Normal and Critical depth File
! !
! !**********************************************************************************************************************!
! !**********************************************************************************************************************!
! 
! #ifdef USE_REF_HEIGHT
! 
! !>  Main subroutine to write the normal and critical heights on a result file
! !!
! !! \details This subroutine writes exact result (unknowns \f$S\f$ and \f$Q\f$ for example) in a result file.
! !! \param[in] dof Unknowns of the model.
! !! \param[in] msh Mesh of the model.
! !! \param[in] namefile Name of the output file.
! 
! SUBROUTINE write_ref_height_file( dof, msh, namefile )
!   
!   USE m_common
!   USE m_time_screen
!   USE m_model
!   USE m_user_data
! 
!   implicit none
! 
!   !================================================================================================================!
!   !  Interface Variables
!   !================================================================================================================!
!   
!   type( unk ), intent(in)  ::  dof
!   TYPE(Mesh), intent(in)  ::  msh
!   character(len=*), intent(in)  ::  namefile
!   ! Local variable
!   character(50) ::  filename
! 
!   !================================================================================================================!
!   !  Calculating normal depth 
!   !================================================================================================================!
!   
!   allocate( hn( msh%ncs+3 ) )
!   call computes_normal_depth(msh, dof)
!   
!   !================================================================================================================!
!   !  Calculating critical depth 
!   !================================================================================================================!
! 
!   allocate( hc( msh%ncs+3 ) )
!   call computes_critical_depth(msh, dof)
! 
!   !===================================================================================================================!
!   !  Creating result file
!   !===================================================================================================================!
!   
!   if      ( tc < zerom ) then
!      write(filename,'(A,"_initial")') namefile
!   else if ( abs( tc - ts ) < zerom ) then
!      write(filename,'(A,"_final")') namefile
!   else
!      write(filename,'(A,"_",ES12.6)') namefile , tc
!   end if
!   
!   filename = trim(filename)//'.dat'
!   open(10, file=filename, status='replace', form='formatted')
!   write(10,*) '# File with the normal and critical depth at each point of the msh'
!   write(10,*) '#  hn            hc'
!   do i=3,msh%ncs+2
!      write(10,'(2ES16.8)') hn(i), hc(i)
!   end do
!   close(10)
! 
!   deallocate(hn)
!   deallocate(hc)
!   
! END SUBROUTINE write_ref_height_file
! 
! #endif
! 
! 
! !**********************************************************************************************************************!
! !**********************************************************************************************************************!
! !
! !  Write a restart direct file
! !
! !**********************************************************************************************************************!
! !**********************************************************************************************************************!
! 
! !>  Write a restart direct file
! !!
! !! \details This subroutine writes a restart direct file. This file is read if the computation have been stopped. 
! !! It is possible to use this file to impose initial condition.  
! !! \param[in]    dof Unknowns of the model.
! !! \param[in]    msh Mesh of the model.
! SUBROUTINE write_restart_direct( dof , msh )
! 
!    USE m_common
!    USE m_model
! 
!    implicit none
! 
!    !===================================================================================================================!
!    !  Interface Variables
!    !===================================================================================================================!
! 
!    type( unk ), intent(in)  ::  dof
!    type(Mesh), intent(in)  ::  msh
! 
!    real(rp) :: q
!    !===================================================================================================================!
!    !  Begin Subroutine
!    !===================================================================================================================!
! 
! 
!    open(10,file='restart.bin',status='replace',form='unformatted',access='direct',recl=3*length_real)
! 
!    write(10,rec=1) tc
! 
!    close(10)
! 
! 
!    open(10,file='restart.bin',status='old',form='unformatted',access='direct',recl=3*length_real)
! 
! 
!    if (Qinterface.eq.1) then
!       do i = 1,msh%ncs+3
!          q=(0.5_rp*tflux1(i  )*msh%cs(i  )%deltademi + &
!             0.5_rp*tflux1(i+1)*msh%cs(i+1)%deltademi)/ &
!             msh%cs(i)%delta
!          write(10,rec=1+i) dof%h(i) , dof%s(i) , q
!       end do
!          write(10,rec=1+i) dof%h(msh%ncs+4) , dof%s(msh%ncs+4) , dof%q(msh%ncs+4)
!    else 
!       do i = 1,msh%ncs+4
!          write(10,rec=1+i) dof%h(i) , dof%s(i) , dof%q(i)
!       end do
!    end if 
! 
!    close(10)
! 
!    
! END SUBROUTINE write_restart_direct
! 
! 
! 
! 
! !**********************************************************************************************************************!
! !**********************************************************************************************************************!
! !
! !  Write Exact Solution File
! !
! !**********************************************************************************************************************!
! !**********************************************************************************************************************!
! 
! 
! ! #ifdef USE_VALID
! 
!    !>  Main subroutine to write exact solution on a result file
!    !!
!    !! \details This subroutine writes exact result (unknowns \f$S\f$ and \f$Q\f$ for example) in a result file.
!    !! This subroutine is usable when the exact solution of the model is avaible (analytics solution define in
!    !! m_user.f90 file).  
!    !! \param[in]    msh Mesh of the model.
! 
!    SUBROUTINE write_exact_solution( msh )
! 
!       USE m_common
!       USE m_time_screen
!       USE m_model
!       USE m_user_data
! 
!       implicit none
! 
!       !================================================================================================================!
!       !  Interface Variables
!       !================================================================================================================!
! 
!       TYPE(Mesh), intent(in)  ::  msh
! 
!       !================================================================================================================!
!       !  Local Variables
!       !================================================================================================================!
! 
!       TYPE( unk )  ::  dof_exact
! 
!       real(rp) :: geo_cs_Atoh
! 
!       !================================================================================================================!
!       !  Calculating exact solution
!       !================================================================================================================!
! 
!       call alloc_dof( dof_exact , msh )
! 
!       do i = 3,msh%ncs+2
! 
!          dof_exact%S(i) = max( 0._rp , S_exact( msh%cs(i)%coord%x , msh%cs(i)%coord%y , tc ) )
! 
! 
!          dof_exact%h(i) = geo_cs_Atoh(msh%cs(i), dof_exact%S(i))
! 
! 
!          if ( dof_exact%s(i) <= 0._rp ) then
! 
!             dof_exact%Q(i) = 0._rp
! 
!          else
! 
!             dof_exact%Q(i) = q_exact( msh%cs(i)%coord%x , msh%cs(i)%coord%y , tc )
!          end if
! 
!       end do
! 
!       !================================================================================================================!
!       !  Writing exact solution
!       !================================================================================================================!
! 
!       call write_result_file( dof_exact , msh , 'res/result_exact' )
! 
!       call dealloc_dof( dof_exact )
! 
!    END SUBROUTINE write_exact_solution
! 
! ! #endif
! 
! 
! 
!    
! !**********************************************************************************************************************!
! !**********************************************************************************************************************!
! !
! !  Write an Raw Binary Output Result File
! !
! !**********************************************************************************************************************!
! !**********************************************************************************************************************!
! 
! !>  Main subroutine to write a result file in raw binary format
! !!
! !! \details This subroutine writes result (unknowns \f$S\f$ and \f$Q\f$ for example) in a result file from a namefile
! !! in raw binary format.  
! !! \param[in]    dof Unknowns of the model.
! !! \param[in]    msh Mesh of the model.
! !! \param[in]    filename Name of the file.
! SUBROUTINE v_rawbin( dof , msh , filename )
! 
!    USE m_common
!    USE m_model
! 
!    implicit none
! 
!    !===================================================================================================================!
!    !  Interface Variables
!    !===================================================================================================================!
! 
!    TYPE( unk ), intent(in)  ::  dof
!    TYPE(Mesh), intent(in)  ::  msh
! 
!    character(len=*), intent(in)  ::  filename
! 
!    !===================================================================================================================!
!    !  Local Variables
!    !===================================================================================================================!
! 
!    real(rp)  ::  q
! 
!    !===================================================================================================================!
!    !  Begin Subroutine
!    !===================================================================================================================!
!    open(10,file=filename,status='replace',access='stream')
! 
!    !===================================================================================================================!
!    !   Writing raw binary file data
!    !===================================================================================================================!
! 
!    if ((Qinterface.eq.1).and.(tc.ne.0._rp)) then 
!       do i = 3,msh%ncs+2
!          q=(0.5_rp*tflux1(i  )*msh%cs(i  )%deltademi + &
!             0.5_rp*tflux1(i+1)*msh%cs(i+1)%deltademi)/ &
!            msh%cs(i)%delta
! 
!          write(10) msh%cs(i)%coord%x    , &
!                    msh%cs(i)%coord%y    , &
!                    bathy_cell(i) + dof%h(i)        , &
!                    dof%S(i)                        , &
!                    q
!                                   
!       end do
!    else 
! 
!       do i = 3,msh%ncs+2
!          write(10) msh%cs(i)%coord%x    , &
!                    msh%cs(i)%coord%y    , &
!                    bathy_cell(i) + dof%h(i)        , &
!                    dof%S(i)                        , &
!                    dof%Q(i)
!       end do
! 
!    endif
! 
!    close(10)
! 
! 
! END SUBROUTINE v_rawbin
! 
! 
! 
!    
! !**********************************************************************************************************************!
! !**********************************************************************************************************************!
! !
! !  Write an Gnuplot Output Result File
! !
! !**********************************************************************************************************************!
! !**********************************************************************************************************************!
! 
! !>  Main subroutine to write a result file in gnuplot format
! !!
! !! \details This subroutine writes result (unknowns \f$S\f$ and \f$Q\f$ for example) in a result file from a namefile
! !! in gnuplot format.  
! !! \param[in]    dof Unknowns of the model.
! !! \param[in]    msh Mesh of the model.
! !! \param[in]    filename Name of the file.
! SUBROUTINE v_gnuplot( dof , msh , filename )
! 
!    USE m_common
!    USE m_model
! 
!    implicit none
! 
!    !===================================================================================================================!
!    !  Interface Variables
!    !===================================================================================================================!
! 
!    TYPE( unk ), intent(in)  ::  dof
!    TYPE(Mesh), intent(in)  ::  msh
! 
!    character(len=*), intent(in)  ::  filename
! 
!    !===================================================================================================================!
!    !  Local Variables
!    !===================================================================================================================!
! 
!    real(rp)  ::  h , u , v ,fr,q, w
! 
!    !===================================================================================================================!
!    !  Functions
!    !===================================================================================================================!
!    real(rp)  :: geo_cs_htoW
! 
!    !===================================================================================================================!
!    !  Begin Subroutine
!    !===================================================================================================================!
! 
!    open(10,file=filename,status='replace',form='formatted')
! 
!    !===================================================================================================================!
!    !   Creating Gnuplot file and header
!    !===================================================================================================================!
! 
!    write(10,*) '# Gnuplot DataFile Version'
!    
! 
!    !===================================================================================================================!
!    !   Writing VTK file datas
!    !===================================================================================================================!
!    if ((Qinterface.eq.1).and.(tc.ne.0._rp)) then 
!       if (w_froude.eq.1) then
!          write(10,*) '#             x               y           bathy               S            Qint'//&
!                      '               h          Froude'
!          do i = 3,msh%ncs+2
!             fr=div_by_except_0(div_by_except_0(dof%Q(i),dof%S(i)),sqrt(g*dof%h(i)))
!             w = geo_cs_htoW(msh%cs(i), dof%h(i))
!             if (dof%S(i) < 1e-12) then
!                fr=0.0
!             else
!                fr=sqrt(dof%Q(i)**2 * w / (g * dof%S(i)**3))
!             end if
!             q=(0.5_rp*tflux1(i  )*msh%cs(i  )%deltademi + &
!                0.5_rp*tflux1(i+1)*msh%cs(i+1)%deltademi)/ &
!                msh%cs(i)%delta
! 
!             write(10,'(8ES16.8)') msh%cs(i)%coord%x    , &
!                                   msh%cs(i)%coord%y    , &
!                                   bathy_cell(i)                   , &
!                                   dof%S(i)                        , &
!                                   q                               , &
!                                   dof%h(i)                        , &
!                                   fr
!                                   
!          end do
!       else 
!          write(10,*) '#             x               y           bathy               S            Qint'//&
!                      '               h'
!          do i = 3,msh%ncs+2
!             q=(0.5_rp*tflux1(i  )*msh%cs(i  )%deltademi + &
!                0.5_rp*tflux1(i+1)*msh%cs(i+1)%deltademi)/ &
!                msh%cs(i)%delta         
!             write(10,'(7ES16.8)') msh%cs(i)%coord%x    , &
!                                   msh%cs(i)%coord%y    , &
!                                   bathy_cell(i)                   , &
!                                   dof%S(i)                        , &
!                                   q                               , &
!                                   dof%h(i)
!                                   
!          end do
!       endif
! 
! 
!    else 
! 
!       if (w_froude.eq.1) then
!          write(10,*) '#             x               y           bathy               S            Qint'//&
!                      '               h          Froude'
!          do i = 3,msh%ncs+2
!             fr=div_by_except_0(div_by_except_0(dof%Q(i),dof%S(i)),sqrt(g*dof%h(i)))
!             w = geo_cs_htoW(msh%cs(i), dof%h(i))
!             if (dof%S(i) < 1e-12) then
!                fr=0.0
!             else
!                fr=sqrt(dof%Q(i)**2 * w / (g * dof%S(i)**3))
!             end if
! 
!             write(10,'(8ES16.8)') msh%cs(i)%coord%x    , &
!                                   msh%cs(i)%coord%y    , &
!                                   bathy_cell(i)                   , &
!                                   dof%S(i)                        , &
!                                   dof%Q(i)                        , &
!                                   dof%h(i)                        , &
!                                   fr
!                                   
!          end do
!       else 
!          write(10,*) '#             x               y           bathy               S            Qint'//&
!                      '               h'
!          do i = 3,msh%ncs+2
!          
!             write(10,'(7ES16.8)') msh%cs(i)%coord%x    , &
!                                   msh%cs(i)%coord%y    , &
!                                   bathy_cell(i)                   , &
!                                   dof%S(i)                        , &
!                                   dof%Q(i)                        , &
!                                   dof%h(i)
!                                   
!          end do
!       endif
! 
! 
!    endif
! 
!    close(10)
! 
! 
! END SUBROUTINE v_gnuplot
! 
! 
! 
!    
! !**********************************************************************************************************************!
! !**********************************************************************************************************************!
! !
! !  Write an Gnuplot Output Result File
! !
! !**********************************************************************************************************************!
! !**********************************************************************************************************************!
! 
! !>  Main subroutine to write a result file in gnuplot format (with extended results)
! !!
! !! \details This subroutine writes result (unknowns \f$S\f$ and \f$Q\f$ for example) in a result file from a namefile
! !! in gnuplot format.  
! !! \param[in]    dof Unknowns of the model.
! !! \param[in]    msh Mesh of the model.
! !! \param[in]    filename Name of the file.
! SUBROUTINE v_gnuplot_ext( dof , msh , filename )
! 
!    USE m_common
!    USE m_model
! 
!    implicit none
! 
!    !===================================================================================================================!
!    !  Interface Variables
!    !===================================================================================================================!
! 
!    TYPE( unk ), intent(in)  ::  dof
!    TYPE(Mesh), intent(in)  ::  msh
! 
!    character(len=*), intent(in)  ::  filename
! 
!    !===================================================================================================================!
!    !  Local Variables
!    !===================================================================================================================!
! 
! !    integer(ip), dimension(msh%ncs+4) :: mvector
!    
!    real(rp)  ::  h , u , v , fr , P, Rh, q
! 
!    !===================================================================================================================!
!    !  Extern functions
!    !===================================================================================================================!
!    
!    real(rp)  :: geo_cs_htoP
! 
!    !===================================================================================================================!
!    !  Begin Subroutine
!    !===================================================================================================================!
! 
!    open(10,file=filename,status='replace',form='formatted')
! 
!    !===================================================================================================================!
!    !   Creating Gnuplot file and header
!    !===================================================================================================================!
! 
!    write(10,*) '# Gnuplot DataFile Version'
!    
! 
!    !===================================================================================================================!
!    !   Writing VTK file datas
!    !===================================================================================================================!
! !    call UpdateMVector(msh,dof,mvector)
! 
!    if ((Qinterface.eq.1).and.(tc.ne.0._rp)) then 
!       if (w_froude.eq.1) then
!          write(10,*) '#             x               y           bathy               S            Qint'//&
!                      '               h              Rh          Froude'
!          do i = 3,msh%ncs+2
!             q=(0.5_rp*tflux1(i  )*msh%cs(i  )%deltademi + &
!                0.5_rp*tflux1(i+1)*msh%cs(i+1)%deltademi)/ &
!                msh%cs(i)%delta
!             P = geo_cs_htoP(msh%cs(i), dof%h(i))
!             Rh = dof%S(i) / P
!             fr=div_by_except_0(div_by_except_0(dof%Q(i),dof%S(i)),sqrt(g*dof%h(i)))
! 
!             write(10,'(9ES16.8)') msh%cs(i)%coord%x    , &
!                                   msh%cs(i)%coord%y    , &
!                                   bathy_cell(i)                   , &
!                                   dof%S(i)                        , &
!                                   q                               , &
!                                   dof%h(i)                        , &
!                                   Rh                              , &
!                                   fr
!                                   
!          end do
!       else 
!          write(10,*) '#             x               y           bathy               S            Qint'//&
!                      '               h              Rh'
!          do i = 3,msh%ncs+2
!             q=(0.5_rp*tflux1(i  )*msh%cs(i  )%deltademi + &
!                0.5_rp*tflux1(i+1)*msh%cs(i+1)%deltademi)/ &
!                msh%cs(i)%delta         
!             P = geo_cs_htoP(msh%cs(i), dof%h(i))
!             Rh = dof%S(i) / P
!             write(10,'(8ES16.8)') msh%cs(i)%coord%x    , &
!                                   msh%cs(i)%coord%y    , &
!                                   bathy_cell(i)                   , &
!                                   dof%S(i)                        , &
!                                   q                               , &
!                                   dof%h(i)                        , &
!                                   Rh
!                                   
!          end do
!       endif
! 
! 
!    else 
! 
!       if (w_froude.eq.1) then
!          write(10,*) '#             x               y           bathy               S               Q'//&
!                      '               h              Rh          Froude'
!          do i = 3,msh%ncs+2
!             P = geo_cs_htoP(msh%cs(i), dof%h(i))
!             Rh = dof%S(i) / P
!             fr=div_by_except_0(div_by_except_0(dof%Q(i),dof%S(i)),sqrt(g*dof%h(i)))
!             write(10,'(9ES16.8)') msh%cs(i)%coord%x    , &
!                                   msh%cs(i)%coord%y    , &
!                                   bathy_cell(i)                   , &
!                                   dof%S(i)                        , &
!                                   dof%Q(i)                        , &
!                                   dof%h(i)                        , &
!                                   Rh                              , &
!                                   fr
!                                   
!          end do
!       else 
!          write(10,*) '#             x               y           bathy               S               Q'//&
!                      '               h              Rh'
!          do i = 3,msh%ncs+2
!          
!             P = geo_cs_htoP(msh%cs(i), dof%h(i))
!             Rh = dof%S(i) / P
!             write(10,'(8ES16.8)') msh%cs(i)%coord%x    , &
!                                   msh%cs(i)%coord%y    , &
!                                   bathy_cell(i)                   , &
!                                   dof%S(i)                        , &
!                                   dof%Q(i)                        , &
!                                   dof%h(i)                        , &
!                                   Rh
!                                   
!          end do
!       endif
! 
! 
!    endif
! 
!    close(10)
! 
! 
! END SUBROUTINE v_gnuplot_ext
! 
! 
! 
!    
! !**********************************************************************************************************************!
! !**********************************************************************************************************************!
! !
! !  Write an Gnuplot Output Result File
! !
! !**********************************************************************************************************************!
! !**********************************************************************************************************************!
! 
! !>  Main subroutine to write a result file in gnuplot format (with F4 gradients)
! !!
! !! \details This subroutine writes result (unknowns \f$S\f$ and \f$Q\f$ for example) in a result file from a namefile
! !! in gnuplot format.  
! !! \param[in]    dof Unknowns of the model.
! !! \param[in]    msh Mesh of the model.
! !! \param[in]    filename Name of the file.
! SUBROUTINE v_gnuplot_dF4( dof , msh , filename )
! 
!    USE m_common
!    USE m_model
! 
!    implicit none
! 
!    !===================================================================================================================!
!    !  Interface Variables
!    !===================================================================================================================!
! 
!    TYPE( unk ), intent(in)  ::  dof
!    TYPE(Mesh), intent(in)  ::  msh
! 
!    character(len=*), intent(in)  ::  filename
! 
!    !===================================================================================================================!
!    !  Local Variables
!    !===================================================================================================================!
! 
!    integer(ip), dimension(msh%ncs+4) :: mvector
!    
!    real(rp)  ::  h , u , v , fr , P, Rh, q
!    real(rp), dimension(msh%ncs+4) :: Ks   ! Strickler
!    real(rp), dimension(4) :: dF4          ! Gradients of F4 force term
! 
!    !===================================================================================================================!
!    !  Extern functions
!    !===================================================================================================================!
!    
!    real(rp)  :: geo_cs_htoP
! 
!    !===================================================================================================================!
!    !  Begin Subroutine
!    !===================================================================================================================!
! 
!    open(10,file=filename,status='replace',form='formatted')
! 
!    !===================================================================================================================!
!    !   Creating Gnuplot file and header
!    !===================================================================================================================!
! 
!    write(10,*) '# Gnuplot DataFile Version'
!    write(10,*) '#             x               y           dF4dK           dF4dA          dF4dRh' // &
!                '           dF4dQ'
! 
!    !===================================================================================================================!
!    !   Writing VTK file datas
!    !===================================================================================================================!
! !    call UpdateMVector(msh,dof,mvector)
! !    call calc_K_everywhere(dof, msh, Manning, mvector)                      ! Update of Manning
!    call update_all_levels(msh, dof%h)
!    call mesh_compute_stricklers(msh, dof, Ks)                      ! Update of Ks
!    
!    do i = 3,msh%ncs+2
!       if ((Qinterface.eq.1).and.(tc.ne.0._rp)) then 
!          q=(0.5_rp*tflux1(i  )*msh%cs(i  )%deltademi + &
!             0.5_rp*tflux1(i+1)*msh%cs(i+1)%deltademi)/ &
!            msh%cs(i)%delta
!       else
!          q = dof%Q(i)
!       end if
!       call geo_cs_perimeter(msh%cs(i), dof%h(i), P)
!       Rh = dof%S(i) / P
!       
!       dF4(1) = - 2.0_rp * q**2 / (Ks(i)**3 * dof%S(i)**2 * Rh**d4p3)
!       dF4(2) = - 2.0_rp * q**2 / (Ks(i)**2 * dof%S(i)**3 * Rh**d4p3)
!       dF4(3) = - d4p3 * q**2 / (Ks(i)**2 * dof%S(i)**2 * Rh**d7p3)
!       dF4(4) = 2.0_rp * q / (Ks(i)**2 * dof%S(i)**2 * Rh**d4p3)
!       
!       write(10,'(9ES16.8)') msh%cs(i)%coord%x    , &
!                             msh%cs(i)%coord%y    , &
!                             dF4(1)                          , &
!                             dF4(2)                          , &
!                             dF4(3)                          , &
!                             dF4(4)
!                             
!    end do
! 
!    close(10)
! 
! 
! END SUBROUTINE v_gnuplot_dF4
! 
! 
! 
!    
! !**********************************************************************************************************************!
! !**********************************************************************************************************************!
! !
! !  Write an Gnuplot Output Result File
! !
! !**********************************************************************************************************************!
! !**********************************************************************************************************************!
! 
! !>  Main subroutine to write a result file in gnuplot format (with F4 gradients)
! !!
! !! \details This subroutine writes result (unknowns \f$S\f$ and \f$Q\f$ for example) in a result file from a namefile
! !! in gnuplot format.  
! !! \param[in]    dof Unknowns of the model.
! !! \param[in]    msh Mesh of the model.
! !! \param[in]    filename Name of the file.
! SUBROUTINE v_gnuplot_dSf( dof , msh , filename )
! 
!    USE m_common
!    USE m_model
! 
!    implicit none
! 
!    !===================================================================================================================!
!    !  Interface Variables
!    !===================================================================================================================!
! 
!    TYPE( unk ), intent(in)  ::  dof
!    TYPE(Mesh), intent(in)  ::  msh
! 
!    character(len=*), intent(in)  ::  filename
! 
!    !===================================================================================================================!
!    !  Local Variables
!    !===================================================================================================================!
! 
!    integer(ip), dimension(msh%ncs+4) :: mvector
!    
!    real(rp)  ::  h , u , v , fr , P, Rh, q, mult, w0
!    real(rp), dimension(msh%ncs+4) :: Ks   ! Manning
!    real(rp), dimension(4) :: dF4          ! Gradients of F4 force term (raw gradients : dK, dA, dRh, dQ)
!    real(rp), dimension(3) :: dSf          ! Gradients of Sf force term
!    real(rp)               :: dgh          ! Gradients of Sf force term w.r.t. h, e.g. dg(h) in lyx
! 
!    !===================================================================================================================!
!    !  Extern functions
!    !===================================================================================================================!
!    
!    real(rp)  :: PerimeterFromH
! 
!    !===================================================================================================================!
!    !  Begin Subroutine
!    !===================================================================================================================!
! 
!    open(10,file=filename,status='replace',form='formatted')
! 
!    !===================================================================================================================!
!    !   Creating Gnuplot file and header
!    !===================================================================================================================!
! 
!    write(10,*) '# Gnuplot DataFile Version'
!    write(10,*) '#             x               y           dSfdK          dSfdA0           dSfdQ' // &
!                '           dg(h)'
! 
!    !===================================================================================================================!
!    !   Writing VTK file datas
!    !===================================================================================================================!
!    call geo_mesh_update_levels(msh, dof%h)
!    call mesh_compute_stricklers(msh, dof, Ks)                      ! Update of Ks
!    
!    do i = 3,msh%ncs+2
!       if ((Qinterface.eq.1).and.(tc.ne.0._rp)) then 
!          q=(0.5_rp*tflux1(i  )*msh%cs(i  )%deltademi + &
!             0.5_rp*tflux1(i+1)*msh%cs(i+1)%deltademi)/ &
!            msh%cs(i)%delta
!       else
!          q = dof%Q(i)
!       end if
!       call geo_cs_perimeter(msh%cs(i), dof%h(i), P)
!       Rh = dof%S(i) / P
!       w0 = msh%cs(i)%width(1)
!       
!       mult = q / (Ks(i)**2 * dof%S(i)**2 * Rh**d4p3)
!       dSf(1) = mult * (-2.0_rp * q / Ks(i))
!       dSf(2) = mult * (- q / dof%S(i) * (2.0_rp + d4p3 * (1.0_rp - 2.0 * Rh / w0)))
!       dSf(3) = mult * 2.0_rp
!       
!       dF4(2) = - 2.0_rp * q**2 / (Ks(i)**2 * dof%S(i)**3 * Rh**d4p3)
!       dF4(3) = - d4p3 * q**2 / (Ks(i)**2 * dof%S(i)**2 * Rh**d7p3)
!       dgh = dF4(2) + dF4(3) - dSf(2)
!       
! !       
! !       write(10,'(9ES16.8)') msh%cs(i)%coord%x    , &
! !                             msh%cs(i)%coord%y    , &
! !                             dF4(1)                          , &
! !                             dF4(2)                          , &
! !                             dF4(3)                          , &
! !                             dF4(4)
!       
!       write(10,'(9ES16.8)') msh%cs(i)%coord%x    , &
!                             msh%cs(i)%coord%y    , &
!                             dSf(1)                          , &
!                             dSf(2)                          , &
!                             dSf(3)                          , &
!                             dgh
!                             
!    end do
! 
!    close(10)
! 
! 
! END SUBROUTINE v_gnuplot_dSf
! 

