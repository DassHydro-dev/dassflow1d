!======================================================================================================================!
!
!                    DassFlow Version 2.0
!
!======================================================================================================================!
!
!  Copyright University of Toulouse-INSA - CNRS (France)
!
!  This file is part of the DassFlow software (Data Assimilation for Free Surface Flows).
!  DassFlow is a computational software aiming at simulating geophysical free surface flows.
!  It is designed for Variational Data Assimilation (4D-var) and sensitivity analyses. 
! Inverse capabilities are based on the adjoint code which is generated by 
! a source-to-source algorithmic differentiation (Tapenade software used).
!
!  DassFlow software includes few mostly independent "modules" with common architectures and structures:
!    - DassFlow 2DShallow (shallow water equations in (h,q), finite volumes), i.e. the present code.
!    - DassFlow3D  (non-linear Stokes equations, finite elements, mobile geometries, ALE).
!    - DassFlow 1D (shallow water equations in (S,Q), finite volumes or finite differences), river hydraulics.
!  Please consult the DassFlow webpage for more details: http://www.math.univ-toulouse.fr/DassFlow
!
! You have used DassFlow in an article, a scientific document etc ?  How to cite us ? Please consult the webpage.
! 
!  Many people have contributed to the DassFlow developments from the initial version to the latest ones.
!  Current main developers or scientific contributers are:
!               P. Brisset (CNES & Mathematics Institute of Toulouse & INSA Toulouse)
!               F. Couderc (CNRS & Mathematics Institute of Toulouse IMT)
!               P.-A. Garambois (INSA & ICUBE Strasbourg)
!               J. Monnier (INSA & Mathematics Institute of Toulouse IMT).
!               J.-P. Vila (INSA & Mathematics Institute of Toulouse IMT).
!  and former other developers (R. Madec, M. Honnorat and J. Marin).
!
!  Scientific contact : jerome.monnier@insa-toulouse.fr
!  Technical  contacts : frederic.couderc@math.univ-toulouse.fr, pierre.brisset@insa-toulouse.fr
!
!  This software is governed by the CeCILL license under French law and abiding by the rules of distribution
!  of free software. You can use, modify and/or redistribute the software under the terms of the CeCILL license
!  as circulated by CEA, CNRS and INRIA at the following URL: "http://www.cecill.info".
!
!  As a counterpart to the access to the source code and rights to copy, modify and redistribute granted by the
!  license, users are provided only with a limited warranty and the software's author, the holder of the economic
!  rights, and the successive licensors have only limited liability.
!
!  In this respect, the user's attention is drawn to the risks associated with loading, using, modifying and/or
!  developing or reproducing the software by the user in light of its specific status of free software, that may
!  mean that it is complicated to manipulate, and that also therefore means that it is reserved for developers and
!  experienced professionals having in-depth computer knowledge. Users are therefore encouraged to load and test the
!  software's suitability as regards their requirements in conditions enabling the security of their systems and/or
!  data to be ensured and, more generally, to use and operate it in the same conditions as regards security.
!
!  The fact that you are presently reading this means that you have had knowledge of the CeCILL license and that you
!  accept its terms.
!
!======================================================================================================================!
!> \file m_control.f90


!**********************************************************************************************************************!
!**********************************************************************************************************************!
!
!  Module m_control
!
!**********************************************************************************************************************!
!**********************************************************************************************************************!

!> Module m_control.
module m_control
    use m_common
    use m_mesh
    use m_sw_mono, only: Model
    use m_sw_mono, only: Unknowns
#ifndef CPP_ADJ
    use m_linear_algebra, only: MatrixBlock
    use m_linear_algebra, only: MatrixCSR
#endif

    implicit none
    
    !> ControlItem type
    type ControlItem

        !> Identifier (BCXXX, QLATXXX, BATHY, KPARXX)
        character(len=6) :: id
        !> Number of elements in control vector
        integer(ip) :: nx
        !> Offset in control vector
        integer(ip) :: offset
        !> Array of indices for subsets
        integer(ip), dimension(:), allocatable :: subset

    end type ControlItem
    
    !> Control type
    type Control

        !> Number of items
        integer(ip) :: nitems
        !> List of items
        type(ControlItem), dimension(:), allocatable :: items
        !> Values
        real(rp), dimension(:), allocatable :: x
        !> Prior values
        real(rp), dimension(:), allocatable :: x0
        !> Background covariance matrix
        type(MatrixCSR) :: Bdemi
        !> regulirization coefficient
        real(rp) :: coef_reg
	

    end type Control
  
  
#ifndef CPP_ADJ
    interface 
    
        subroutine apply_control(ctrl, mdl)
            import Control
            import Model
            implicit none
            type(Control), intent(inout) :: ctrl
            type(Model), intent(inout) :: mdl
        end subroutine apply_control
        
    end interface
    
        
    contains
    

    subroutine control_initialise(ctrl)
        implicit none
        type(Control), intent(out) :: ctrl
        
        ctrl%nitems = 0
        allocate(ctrl%items(0))
        allocate(ctrl%x(0))
        allocate(ctrl%x0(0))
        ctrl%Bdemi%n = 0
        ctrl%coef_reg = 0
        
    end subroutine


    subroutine control_finalise(ctrl)
        implicit none
        type(Control), intent(inout) :: ctrl
        
        if (allocated(ctrl%x)) deallocate(ctrl%x)
        if (allocated(ctrl%x0)) deallocate(ctrl%x0)
        
    end subroutine


    subroutine set_prior(ctrl, values)
        implicit none
        type(Control) :: ctrl
        real(rp), dimension(:), intent(in) :: values
        
        if (ctrl%nitems == 0 .or. .not.allocated(ctrl%items)) then
            call abort_solver("Control must be initialised")
            return
        end if
        if (size(values) /= size(ctrl%x)) then
            call f90wrap_abort("size(values) must be equal to size(ctrl%x)")
            return
        end if
        
        ctrl%x0(:) = values(:)
        if (ctrl%Bdemi%n > 0) then
            ctrl%x(:) = 0.0_rp
        else
            ctrl%x(:) = ctrl%x0(:)
        end if
        
    end subroutine


    function zero_block_matrix(ctrl) result(mat)
        implicit none
        type(Control), intent(in) :: ctrl
        type(MatrixBlock) :: mat
        ! Iterator on control items
        integer(ip) :: i
        
        if (ctrl%nitems == 0 .or. .not.allocated(ctrl%items)) then
            call abort_solver("Control must be initialised")
            return
        end if
        
        allocate(mat%blocks(ctrl%nitems))
        do i = 1, ctrl%nitems
            allocate(mat%blocks(i)%m(ctrl%items(i)%nx, ctrl%items(i)%nx))
        end do
        
    end function


    subroutine set_prior_error_covariance_matrixblock(ctrl, mat)
!         use m_linear_algebra, only: cholesky_in_place
        implicit none
        type(Control), intent(inout) :: ctrl
        type(MatrixBlock), intent(in) :: mat
        ! Iterator
        integer(ip) :: i
        
        if (.not.allocated(mat%blocks)) then
            call abort_solver("Matrix blocks must be initialised")
            return
        end if
        
        do i = 1, size(mat%blocks)
!             print *, "choleski on block:", i
            call cholesky_inplace(size(mat%blocks(i)%m, 1), mat%blocks(i)%m)
        end do
        
!         print *, "ALLOCATED ???", allocated(ctrl%Bdemi%irow), allocated(ctrl%Bdemi%icol), allocated(ctrl%Bdemi%anz)
        call matrixcsr_from_matrixblock(mat, ctrl%Bdemi)
!         print *, "LOC:irow=", loc(ctrl%Bdemi%irow)
!         print *, "    icol=", loc(ctrl%Bdemi%icol)
!         print *, "    anz =", loc(ctrl%Bdemi%anz)
        
    end subroutine


    subroutine set_prior_error_covariance_matrixdense(ctrl, array)
        implicit none
        type(Control), intent(inout) :: ctrl
        real(rp), dimension(:, :), intent(in) :: array
        
        call cholesky_inplace(size(array, 1), array)
        call matrixcsr_from_numpy_array(array, ctrl%Bdemi)
        
    end subroutine


    subroutine set_prior_cov_demi(ctrl, array)
        implicit none
        type(Control), intent(inout) :: ctrl
        real(rp), dimension(:, :), intent(in) :: array
        
        call matrixcsr_from_numpy_array(array, ctrl%Bdemi)
        
    end subroutine
    
    
    subroutine resize_control_items_array(ctrl, new_size)
        implicit none
        type(Control), intent(inout) :: ctrl
        integer(ip), intent(in) :: new_size

        integer(ip) :: i
        type(ControlItem), dimension(:), allocatable :: old_items

        ! Store existing items
        if (allocated(ctrl%items)) then
        
            allocate(old_items(size(ctrl%items)))
            do i = 1, size(ctrl%items)
                old_items(i)%id = ctrl%items(i)%id
                old_items(i)%nx = ctrl%items(i)%nx
                old_items(i)%offset = ctrl%items(i)%offset
            end do
            deallocate(ctrl%items)
            
        end if
        
        ! Allocate items array with new size
        allocate(ctrl%items(new_size))
        ctrl%nitems = new_size
        
        ! Copy back stored items
        if (allocated(old_items)) then
            do i = 1, min(size(old_items), new_size)
                ctrl%items(i)%id = old_items(i)%id
                ctrl%items(i)%nx = old_items(i)%nx
                ctrl%items(i)%offset = old_items(i)%offset
            end do
            deallocate(old_items)
        end if

    end subroutine
    
    
    subroutine extend_control_items_array(ctrl, n)
        implicit none
        type(Control), intent(inout) :: ctrl
        integer(ip), intent(in) :: n

        integer(ip) :: new_size

        ! Comute new size
        new_size = n
        if (allocated(ctrl%items)) new_size = new_size + size(ctrl%items)
        
        ! Resize items array
        call resize_control_items_array(ctrl, new_size)

    end subroutine


    subroutine add_bc_in_control(ctrl, mdl, index_bc)
        implicit none
        type(Control), intent(inout) :: ctrl
        type(Model), intent(in) :: mdl
        !> Index of boundary condition (first index is 0)
        integer(ip), intent(in) :: index_bc

        integer(ip) :: i
        integer(ip) :: ndata
        integer(ip) :: size_old
        integer(ip) :: size_new
!         character(len=6) :: newid
!         character(len=6) :: newid1
!         character*6 :: newid2
        type(ControlItem), dimension(:), allocatable :: old_items
        
        ! Compute size of new data
        if (mdl%bc(index_bc+1)%id == "discharge" .or. mdl%bc(index_bc+1)%id == "elevation") then
            ndata = size(mdl%bc(index_bc+1)%ts%y)
        else
            call f90wrap_abort("Adding BC with id '"//trim(mdl%bc(index_bc+1)%id)//"' is not implemented yet")
        end if
        
        ! Resize items array
        if (allocated(ctrl%items)) then
            size_old = size(ctrl%items)
            allocate(old_items(size(ctrl%items)))
            do i = 1, size(ctrl%items)
                old_items(i)%id = ctrl%items(i)%id
                old_items(i)%nx = ctrl%items(i)%nx
                old_items(i)%offset = ctrl%items(i)%offset
            end do
            deallocate(ctrl%items)
        else
            size_old = 0
        end if
        allocate(ctrl%items(size_old+1))
        ctrl%nitems = size_old+1
        if (size_old > 0) then
            do i = 1, size_old
                ctrl%items(i)%id = old_items(i)%id
                ctrl%items(i)%nx = old_items(i)%nx
                ctrl%items(i)%offset = old_items(i)%offset
            end do
            deallocate(old_items)
        end if
!         write(newid2, '(A)') "BC"
!         write(newid1, '(A,I3.3)') "BC", index_bc+1
        write(ctrl%items(size(ctrl%items))%id, '(A,I3.3)') "BC", index_bc+1
        if (allocated(ctrl%x)) then
            ctrl%items(size(ctrl%items))%offset = size(ctrl%x)
        else
            ctrl%items(size(ctrl%items))%offset = 0
        end if
        ctrl%items(size(ctrl%items))%nx = ndata
        allocate(ctrl%items(size(ctrl%items))%subset(0))
                
        ! Resize values array
        if (allocated(ctrl%x)) then
            size_old = size(ctrl%x)
        else
            size_old = 0
        end if
        size_new = size_old + ndata
        call alloc_or_realloc_r(ctrl%x, size_new)
        call alloc_or_realloc_r(ctrl%x0, size_new)
        
        ! Set new values
        if (mdl%bc(index_bc+1)%id == "discharge" .or. mdl%bc(index_bc+1)%id == "elevation") then
            ctrl%x(size_old+1:size_new) = mdl%bc(index_bc+1)%ts%y
            ctrl%x0(size_old+1:size_new) = mdl%bc(index_bc+1)%ts%y
        end if
        
    end subroutine


    subroutine add_inflow_in_control(ctrl, mdl, index_ic)
        implicit none
        type(Control), intent(inout) :: ctrl
        type(Model), intent(in) :: mdl
        !> Index of inflow condition (first index is 0)
        integer(ip), intent(in) :: index_ic

        integer(ip) :: i
        integer(ip) :: ndata
        integer(ip) :: offset
!         integer(ip) :: size_old
        integer(ip) :: new_size
!         type(ControlItem), dimension(:), allocatable :: old_items

        ! CHECK-UP
        if (.not. allocated(mdl%ic) .or. mdl%nic == 0) then
            call f90wrap_abort("Model has no inflow condition")
        else if (index_ic < 0 .or. index_ic > size(mdl%ic) - 1) then
            call f90wrap_abort("Wrong inflow condition index")
        end if

        
        ! Compute size of new data
        if (allocated(mdl%ic(index_ic+1)%ts%y)) then
            ndata = size(mdl%ic(index_ic+1)%ts%y)
        else
            call f90wrap_abort("Cannot add an inflow condition with an empty timeseries")
        end if
        
        ! Extend items array
        call extend_control_items_array(ctrl, 1)

        ! Set new item
        write(ctrl%items(size(ctrl%items))%id, '(A,I3.3)') "IC", index_ic+1
        if (allocated(ctrl%x)) then
            ctrl%items(size(ctrl%items))%offset = size(ctrl%x)
        else
            ctrl%items(size(ctrl%items))%offset = 0
        end if
        ctrl%items(size(ctrl%items))%nx = ndata
        allocate(ctrl%items(size(ctrl%items))%subset(0))
                
        ! Extend values array
        offset = ctrl%items(size(ctrl%items))%offset
        call alloc_or_realloc_r(ctrl%x, offset + ndata)
        call alloc_or_realloc_r(ctrl%x0, offset + ndata)
        
        ! Set new values
        ctrl%x(offset+1:offset + ndata) = mdl%ic(index_ic+1)%ts%y
        ctrl%x0(offset+1:offset + ndata) = mdl%ic(index_ic+1)%ts%y
        
    end subroutine


    subroutine add_bathy_in_control(ctrl, mdl, msh)
        implicit none
        type(Control), intent(inout) :: ctrl
        type(Model), intent(in) :: mdl
        type(Mesh), intent(in) :: msh

        integer(ip) :: i
        integer(ip) :: ics
        integer(ip) :: idata
        integer(ip) :: iseg
        integer(ip) :: ndata
        integer(ip) :: size_old
        integer(ip) :: size_new
        character(len=6) :: newid
        type(ControlItem), dimension(:), allocatable :: old_items
        
        ! Compute number of data
        !DEPRECATED
!         if (allocated(msh%bathy_field%y)) then
!             ndata = size(msh%bathy_field%x)
!         else
!             ndata = 0
!             do iseg = 1, msh%nseg
!                 ndata = ndata + msh%seg(iseg)%last_cs - msh%seg(iseg)%first_cs + 1
!             end do
!         end if
        ndata = 0
        do iseg = 1, msh%nseg
            if (allocated(msh%seg(iseg)%bathy_field%y)) then
                ndata = ndata + size(msh%seg(iseg)%bathy_field%y)
            else
                ndata = ndata + msh%seg(iseg)%last_cs - msh%seg(iseg)%first_cs + 1
            end if
        end do
        
        ! Resize items array
        if (allocated(ctrl%items)) then
            size_old = size(ctrl%items)
            allocate(old_items(size(ctrl%items)))
            do i = 1, size(ctrl%items)
                old_items(i)%id = ctrl%items(i)%id
                old_items(i)%nx = ctrl%items(i)%nx
                old_items(i)%offset = ctrl%items(i)%offset
                if (allocated(ctrl%items(i)%subset)) then
                    allocate(old_items(i)%subset(size(ctrl%items(i)%subset)))
                    old_items(i)%subset(:) = ctrl%items(i)%subset(:)
                end if
            end do
            deallocate(ctrl%items)
        else
            size_old = 0
        end if
        allocate(ctrl%items(size_old+1))
        ctrl%nitems = size_old+1
        if (size_old > 0) then
            do i = 1, size_old
                ctrl%items(i)%id = old_items(i)%id
                ctrl%items(i)%nx = old_items(i)%nx
                ctrl%items(i)%offset = old_items(i)%offset
                if (allocated(old_items(i)%subset)) then
                    allocate(ctrl%items(i)%subset(size(old_items(i)%subset)))
                    ctrl%items(i)%subset(:) = old_items(i)%subset(:)
                end if
            end do
            deallocate(old_items)
        end if
        write(ctrl%items(size(ctrl%items))%id, '(A)') "BATHY"
        if (allocated(ctrl%x)) then
            ctrl%items(size(ctrl%items))%offset = size(ctrl%x)
        else
            ctrl%items(size(ctrl%items))%offset = 0
        end if
        ctrl%items(size(ctrl%items))%nx = ndata
                
        ! Resize values array
        if (allocated(ctrl%x)) then
            size_old = size(ctrl%x)
        else
            size_old = 0
        end if
        size_new = size_old + ndata
        call alloc_or_realloc_r(ctrl%x, size_new)
        call alloc_or_realloc_r(ctrl%x0, size_new)
        
        ! Set new values
        ! DEPRECATED
!         if (allocated(msh%bathy_field%y)) then
!             idata = 0
!             do i = 1,size(msh%bathy_field%x)
!                 idata = idata + 1
!                 if (ctrl%Bdemi%n > 0) then
!                     ctrl%x(size_old+idata) = 0.0
!                 else 
!                     ctrl%x(size_old+idata) = msh%bathy_field%y(i)
!                 end if 
!                 ctrl%x0(size_old+idata) = msh%bathy_field%y(i)
!             end do
!         else
!             idata = 0
!             do iseg = 1, msh%nseg
!                 do ics = msh%seg(iseg)%first_cs, msh%seg(iseg)%last_cs
!                     idata = idata + 1
!                     if (ctrl%Bdemi%n > 0) then
!                         ctrl%x(size_old+idata) = 0.0
!                     else 
!                         ctrl%x(size_old+idata) = msh%cs(ics)%bathy
!                     end if 
!                     ctrl%x0(size_old+idata) = msh%cs(ics)%bathy
!                 end do
!             end do
!         end if
        idata = 0
        do iseg = 1, msh%nseg
            if (allocated(msh%seg(iseg)%bathy_field%y)) then
                do i = 1, size(msh%seg(iseg)%bathy_field%y)
                    idata = idata + 1
                    ctrl%x(size_old+idata) = msh%seg(iseg)%bathy_field%y(i)
                    ctrl%x0(size_old+idata) = msh%seg(iseg)%bathy_field%y(i)
                end do
            else
                do ics = msh%seg(iseg)%first_cs, msh%seg(iseg)%last_cs
                    idata = idata + 1
                    ! TODO remove auto set to zero when is defined here or add similar in other methods
                    if (ctrl%Bdemi%n > 0) then
                        ctrl%x(size_old+idata) = 0.0
                    else 
                        ctrl%x(size_old+idata) = msh%cs(ics)%bathy
                    end if 
                    ctrl%x0(size_old+idata) = msh%cs(ics)%bathy
                end do
            end if
        end do
        
    end subroutine


    subroutine add_A0_in_control(ctrl, mdl, msh)
        implicit none
        type(Control), intent(inout) :: ctrl
        type(Model), intent(in) :: mdl
        type(Mesh), intent(in) :: msh

        integer(ip) :: i
        integer(ip) :: ics
        integer(ip) :: idata
        integer(ip) :: iseg
        integer(ip) :: ndata
        integer(ip) :: size_old
        integer(ip) :: size_new
        character(len=6) :: newid
        type(ControlItem), dimension(:), allocatable :: old_items
        
        ! Compute number of data
        !DEPRECATED
!         if (allocated(msh%bathy_field%y)) then
!             ndata = size(msh%bathy_field%x)
!         else
!             ndata = 0
!             do iseg = 1, msh%nseg
!                 ndata = ndata + msh%seg(iseg)%last_cs - msh%seg(iseg)%first_cs + 1
!             end do
!         end if
        ndata = 0
        do iseg = 1, msh%nseg
            if (allocated(msh%seg(iseg)%bathy_field%y)) then
                ndata = ndata + size(msh%seg(iseg)%bathy_field%y)
            else
                ndata = ndata + msh%seg(iseg)%last_cs - msh%seg(iseg)%first_cs + 1
            end if
        end do
        
        ! Resize items array
        if (allocated(ctrl%items)) then
            size_old = size(ctrl%items)
            allocate(old_items(size(ctrl%items)))
            do i = 1, size(ctrl%items)
                old_items(i)%id = ctrl%items(i)%id
                old_items(i)%nx = ctrl%items(i)%nx
                old_items(i)%offset = ctrl%items(i)%offset
                if (allocated(ctrl%items(i)%subset)) then
                    allocate(old_items(i)%subset(size(ctrl%items(i)%subset)))
                    old_items(i)%subset(:) = ctrl%items(i)%subset(:)
                end if
            end do
            deallocate(ctrl%items)
        else
            size_old = 0
        end if
        allocate(ctrl%items(size_old+1))
        ctrl%nitems = size_old+1
        if (size_old > 0) then
            do i = 1, size_old
                ctrl%items(i)%id = old_items(i)%id
                ctrl%items(i)%nx = old_items(i)%nx
                ctrl%items(i)%offset = old_items(i)%offset
                if (allocated(old_items(i)%subset)) then
                    allocate(ctrl%items(i)%subset(size(old_items(i)%subset)))
                    ctrl%items(i)%subset(:) = old_items(i)%subset(:)
                end if
            end do
            deallocate(old_items)
        end if
        write(ctrl%items(size(ctrl%items))%id, '(A)') "A0"
        if (allocated(ctrl%x)) then
            ctrl%items(size(ctrl%items))%offset = size(ctrl%x)
        else
            ctrl%items(size(ctrl%items))%offset = 0
        end if
        ctrl%items(size(ctrl%items))%nx = ndata
                
        ! Resize values array
        if (allocated(ctrl%x)) then
            size_old = size(ctrl%x)
        else
            size_old = 0
        end if
        size_new = size_old + ndata
        call alloc_or_realloc_r(ctrl%x, size_new)
        call alloc_or_realloc_r(ctrl%x0, size_new)
        
        ! Set new values
!         ! DEPRECATED
!         if (allocated(msh%bathy_field%y)) then
!             call abort_solver("Cannot add A0 in control with bathymetry fields")
! !             idata = 0
! !             do i = 1,size(msh%bathy_field%x)
! !                 idata = idata + 1
! !                 ctrl%x(size_old+idata) = msh%bathy_field%y(i)
! !                 ctrl%x0(size_old+idata) = msh%bathy_field%y(i)
! !             end do
!         else
!             idata = 0
!             do iseg = 1, msh%nseg
!                 do ics = msh%seg(iseg)%first_cs, msh%seg(iseg)%last_cs
!                     idata = idata + 1
!                     ctrl%x(size_old+idata) = (msh%cs(ics)%level_heights(1) - msh%cs(ics)%bathy) * msh%cs(ics)%level_widths(1)
!                     ctrl%x0(size_old+idata) = ctrl%x(size_old+idata)
!                 end do
!             end do
!         end if
        ! DEPRECATED
        idata = 0
        do iseg = 1, msh%nseg
            if (allocated(msh%seg(iseg)%bathy_field%y)) then
                call abort_solver("Cannot add A0 in control with bathymetry fields")
            else
                do ics = msh%seg(iseg)%first_cs, msh%seg(iseg)%last_cs
                    idata = idata + 1
                    ctrl%x(size_old+idata) = (msh%cs(ics)%level_heights(1) - msh%cs(ics)%bathy) * msh%cs(ics)%level_widths(1)
                    ctrl%x0(size_old+idata) = ctrl%x(size_old+idata)
                end do
            end if
        end do
        
    end subroutine


    subroutine add_strickler_in_control(ctrl, mdl, msh)
        implicit none
        type(Control), intent(inout) :: ctrl
        type(Model), intent(in) :: mdl
        type(Mesh), intent(in) :: msh

        integer(ip) :: i
        integer(ip) :: ics
        integer(ip) :: idata
        integer(ip) :: ifield
        integer(ip) :: iseg
        integer(ip) :: ndata
        integer(ip) :: nfields
        integer(ip) :: size_old
        integer(ip) :: size_new
        character(len=6) :: newid
        type(ControlItem), dimension(:), allocatable :: old_items
        
        ! Compute number of data
        if (msh%strickler_type_code == strickler_type_constant) then
            nfields = 1
        else if (msh%strickler_type_code == strickler_type_powerlaw_h) then
            nfields = 2
#ifdef STRICKLER_EINSTEIN
        else if (msh%strickler_type_code == strickler_type_einstein) then
            nfields = 3
#endif
#ifdef AVERAGE_CONVEYANCE
        else if (msh%strickler_type_code == strickler_type_average_conveyance) then
            nfields = 3
#endif
#ifdef DEBORD_FORMULA
        else if (msh%strickler_type_code == strickler_type_debord) then
            nfields = 3
#endif
        else
            call abort_solver("Wrong strickler type:"//msh%strickler_type)
        end if
        ndata = 0
        do iseg = 1, mdl%msh%nseg
            if (allocated(msh%seg(iseg)%strickler_fields) .and. &
                size(msh%seg(iseg)%strickler_fields) > 0) then
                ndata = ndata + size(msh%seg(iseg)%strickler_fields(1)%x)
            else
                ndata = ndata + msh%seg(iseg)%last_cs - msh%seg(iseg)%first_cs + 1
            end if
        end do
        
        ! Resize items array
        if (allocated(ctrl%items)) then
            size_old = size(ctrl%items)
            allocate(old_items(size(ctrl%items)))
            do i = 1, size(ctrl%items)
                old_items(i)%id = ctrl%items(i)%id
                old_items(i)%nx = ctrl%items(i)%nx
                old_items(i)%offset = ctrl%items(i)%offset
                if (allocated(ctrl%items(i)%subset)) then
                    allocate(old_items(i)%subset(size(ctrl%items(i)%subset)))
                    old_items(i)%subset(:) = ctrl%items(i)%subset(:)
                end if
            end do
            deallocate(ctrl%items)
        else
            size_old = 0
        end if
        
        allocate(ctrl%items(size_old+nfields))
        ctrl%nitems = size_old+nfields
        if (size_old > 0) then
            do i = 1, size_old
                ctrl%items(i)%id = old_items(i)%id
                ctrl%items(i)%nx = old_items(i)%nx
                ctrl%items(i)%offset = old_items(i)%offset
                if (allocated(old_items(i)%subset)) then
                    allocate(ctrl%items(i)%subset(size(old_items(i)%subset)))
                    ctrl%items(i)%subset(:) = old_items(i)%subset(:)
                end if
            end do
            deallocate(old_items)
        end if
        do i = 1, nfields
            write(ctrl%items(size(ctrl%items)-nfields+i)%id, '(A,I2.2)') "KPAR", i
            if (allocated(ctrl%x)) then
                ctrl%items(size(ctrl%items)-nfields+i)%offset = size(ctrl%x) + (i-1) * ndata
            else
                ctrl%items(size(ctrl%items)-nfields+i)%offset = (i-1) * ndata
            end if
            ctrl%items(size(ctrl%items)-nfields+i)%nx = ndata
        end do
    !       if (msh%strickler_type_code == strickler_type_constant) then
    !           allocate(ctrl%items(size_old+1))
    !           if (size_old > 0) then
    !               do i = 1, size_old
    !                   ctrl%items(i)%id = old_items(i)%id
    !                   ctrl%items(i)%nx = old_items(i)%nx
    !                   ctrl%items(i)%offset = old_items(i)%offset
    !                   if (allocated(old_items(i)%subset)) then
    !                     allocate(ctrl%items(i)%subset(size(old_items(i)%subset)))
    !                     ctrl%items(i)%subset(:) = old_items(i)%subset(:)
    !                   end if
    !               end do
    !               deallocate(old_items)
    !           end if
    !           write(ctrl%items(size(ctrl%items))%id, '(A)') "KPAR01"
    !           if (allocated(ctrl%x)) then
    !               ctrl%items(size(ctrl%items))%offset = size(ctrl%x)
    !           else
    !               ctrl%items(size(ctrl%items))%offset = 0
    !           end if
    !           ctrl%items(size(ctrl%items))%nx = ndata
    !       else if (msh%strickler_type_code == strickler_type_powerlaw_h) then
    !           allocate(ctrl%items(size_old+2))
    !           if (size_old > 0) then
    !               do i = 1, size_old
    !                   ctrl%items(i)%id = old_items(i)%id
    !                   ctrl%items(i)%nx = old_items(i)%nx
    !                   ctrl%items(i)%offset = old_items(i)%offset
    !                   if (allocated(old_items(i)%subset)) then
    !                     allocate(ctrl%items(i)%subset(size(old_items(i)%subset)))
    !                     ctrl%items(i)%subset(:) = old_items(i)%subset(:)
    !                   end if
    !               end do
    !               deallocate(old_items)
    !           end if
    !           write(ctrl%items(size(ctrl%items)-1)%id, '(A)') "KPAR01"
    !           if (allocated(ctrl%x)) then
    !               ctrl%items(size(ctrl%items)-1)%offset = size(ctrl%x)
    !           else
    !               ctrl%items(size(ctrl%items)-1)%offset = 0
    !           end if
    !           ctrl%items(size(ctrl%items)-1)%nx = ndata
    !           write(ctrl%items(size(ctrl%items))%id, '(A)') "KPAR02"
    !           if (allocated(ctrl%x)) then
    !               ctrl%items(size(ctrl%items))%offset = size(ctrl%x) + ndata
    !           else
    !               ctrl%items(size(ctrl%items))%offset = ndata
    !           end if
    !           ctrl%items(size(ctrl%items))%nx = ndata
    !           
    !       end if
                    
        ! Resize values array
        if (allocated(ctrl%x)) then
            size_old = size(ctrl%x)
        else
            size_old = 0
        end if
        size_new = size_old + ndata * nfields
        call alloc_or_realloc_r(ctrl%x, size_new)
        call alloc_or_realloc_r(ctrl%x0, size_new)
    !       if (msh%strickler_type_code == strickler_type_constant) then
    !           size_new = size_old + ndata
    !           call alloc_or_realloc_r(ctrl%x, size_new)
    !           call alloc_or_realloc_r(ctrl%x0, size_new)
    !       else if (msh%strickler_type_code == strickler_type_powerlaw_h) then
    !           size_new = size_old + 2 * ndata
    !           call alloc_or_realloc_r(ctrl%x, size_new)
    !           call alloc_or_realloc_r(ctrl%x0, size_new)
    !       end if
            
        ! Set new values
        idata = size_old
        do ifield = 1, nfields
            do iseg = 1, msh%nseg
                if (allocated(msh%seg(iseg)%strickler_fields) .and. &
                    size(msh%seg(iseg)%strickler_fields) > 0) then
                    do i = 1, size(msh%seg(iseg)%strickler_fields(ifield)%x)
                        idata = idata + 1
			!write(6,*) "test",iseg,i,idata
                        ctrl%x(idata) = msh%seg(iseg)%strickler_fields(ifield)%y(i)
                        ctrl%x0(idata) = msh%seg(iseg)%strickler_fields(ifield)%y(i)
                    end do
                else 
                    do ics = msh%seg(iseg)%first_cs, msh%seg(iseg)%last_cs
                        idata = idata + 1
                        ctrl%x(idata) = msh%cs(ics)%strickler_params(ifield)
                        ctrl%x0(idata) = msh%cs(ics)%strickler_params(ifield)
                    end do
                end if 
            end do
        end do

        !if (allocated(msh%strickler_fields)) then
        !    idata = size_old
        !    do ifield = 1, nfields
        !        do i = 1, size(msh%strickler_fields(1)%x)
        !            idata = idata + 1
        !            ctrl%x(idata) = msh%strickler_fields(ifield)%y(i)
        !            ctrl%x0(idata) = msh%strickler_fields(ifield)%y(i)
        !        end do
        !    end do
        !else
        !    idata = size_old
        !    do ifield = 1, nfields
        !        do iseg = 1, msh%nseg
        !            do ics = msh%seg(iseg)%first_cs, msh%seg(iseg)%last_cs
        !                idata = idata + 1
        !                ctrl%x(idata) = msh%cs(ics)%strickler_params(ifield)
        !                ctrl%x0(idata) = msh%cs(ics)%strickler_params(ifield)
        !            end do
        !        end do
        !    end do
        !end if
    !       if (msh%strickler_type == strickler_type_constant) then
    !           if (allocated(msh%strickler_fields)) then
    !               idata = 0
    !               do i = 1, size(msh%strickler_fields(1)%x)
    !                   idata = idata + 1
    !                   ctrl%x(size_old+idata) = msh%strickler_fields(1)%y(i)
    !                   ctrl%x0(size_old+idata) = msh%strickler_fields(1)%y(i)
    !               end do
    !           else
    !               idata = 0
    !               do iseg = 1, msh%nseg
    !                   do ics = msh%seg(iseg)%first_cs, msh%seg(iseg)%last_cs
    !                       idata = idata + 1
    !                       ctrl%x(size_old+idata) = msh%cs(ics)%strickler_params(1)
    !                       ctrl%x0(size_old+idata) = msh%cs(ics)%strickler_params(1)
    !                   end do
    !               end do
    !           end if
    !       else if (msh%strickler_type == strickler_type_powerlaw_h) then
    !           if (allocated(msh%strickler_fields)) then
    !               idata = 0
    !               do i = 1, size(msh%strickler_fields(1)%x)
    !                   idata = idata + 1
    !                   ctrl%x(size_old+idata) = msh%strickler_fields(1)%y(i)
    !                   ctrl%x(size_old+ndata+idata) = msh%strickler_fields(2)%y(i)
    !                   ctrl%x0(size_old+idata) = msh%strickler_fields(1)%y(i)
    !                   ctrl%x0(size_old+ndata+idata) = msh%strickler_fields(2)%y(i)
    !               end do
    !           else
    !               idata = 0
    !               do iseg = 1, msh%nseg
    !                   do ics = msh%seg(iseg)%first_cs, msh%seg(iseg)%last_cs
    !                       idata = idata + 1
    !                       ctrl%x(size_old+idata) = msh%cs(ics)%strickler_params(1)
    !                       ctrl%x(size_old+ndata+idata) = msh%cs(ics)%strickler_params(2)
    !                       ctrl%x0(size_old+idata) = msh%cs(ics)%strickler_params(1)
    !                       ctrl%x0(size_old+ndata+idata) = msh%cs(ics)%strickler_params(2)
    !                   end do
    !               end do
    !           end if
    !       end if
        
    end subroutine


    subroutine add_strickler_component_in_control(ctrl, mdl, msh, component)
        implicit none
        type(Control), intent(inout) :: ctrl
        type(Model), intent(in) :: mdl
        type(Mesh), intent(in) :: msh
        integer(ip), intent(in) :: component

        integer(ip) :: i
        integer(ip) :: ics
        integer(ip) :: idata
!         integer(ip) :: ifield
        integer(ip) :: iseg
        integer(ip) :: ndata
        integer(ip) :: nfields
        integer(ip) :: size_old
        integer(ip) :: size_new
        character(len=6) :: newid
        character(len=32) :: tmp
        type(ControlItem), dimension(:), allocatable :: old_items
        
        ! Check component index
        if (msh%strickler_type_code == strickler_type_constant) then
            if (component > 0) then
                write(tmp, '(I32)') component
                call abort_solver("Wrong component index:"//trim(adjustl(tmp)))
            end if
        else if (msh%strickler_type_code == strickler_type_powerlaw_h) then
            if (component > 1) then
                write(tmp, '(I32)') component
                call abort_solver("Wrong component index:"//trim(adjustl(tmp)))
            end if
#ifdef STRICKLER_EINSTEIN
        else if (msh%strickler_type_code == strickler_type_einstein) then
            if (component > 2) then
                write(tmp, '(I32)') component
                call abort_solver("Wrong component index:"//trim(adjustl(tmp)))
            end if
#endif
#ifdef AVERAGE_CONVEYANCE
        else if (msh%strickler_type_code == strickler_type_average_conveyance) then
            if (component > 2) then
                write(tmp, '(I32)') component
                call abort_solver("Wrong component index:"//trim(adjustl(tmp)))
            end if
#endif
#ifdef DEBORD_FORMULA
        else if (msh%strickler_type_code == strickler_type_debord) then
            if (component > 2) then
                write(tmp, '(I32)') component
                call abort_solver("Wrong component index:"//trim(adjustl(tmp)))
            end if
#endif
        else
            call abort_solver("Wrong strickler type:"//msh%strickler_type)
        end if
        ndata = 0
        do iseg = 1, mdl%msh%nseg
            if (allocated(msh%seg(iseg)%strickler_fields) .and. &
                size(msh%seg(iseg)%strickler_fields) > 0) then
                ndata = ndata + size(msh%seg(iseg)%strickler_fields(1)%x)
            else
                ndata = ndata + msh%seg(iseg)%last_cs - msh%seg(iseg)%first_cs + 1
            end if
        end do
        
        ! Resize items array
        if (allocated(ctrl%items)) then
            size_old = size(ctrl%items)
            allocate(old_items(size(ctrl%items)))
            do i = 1, size(ctrl%items)
                old_items(i)%id = ctrl%items(i)%id
                old_items(i)%nx = ctrl%items(i)%nx
                old_items(i)%offset = ctrl%items(i)%offset
                if (allocated(ctrl%items(i)%subset)) then
                    allocate(old_items(i)%subset(size(ctrl%items(i)%subset)))
                    old_items(i)%subset(:) = ctrl%items(i)%subset(:)
                end if
            end do
            deallocate(ctrl%items)
        else
            size_old = 0
        end if
        
        allocate(ctrl%items(size_old+1))
        ctrl%nitems = size_old+1
        if (size_old > 0) then
            do i = 1, size_old
                ctrl%items(i)%id = old_items(i)%id
                ctrl%items(i)%nx = old_items(i)%nx
                ctrl%items(i)%offset = old_items(i)%offset
                if (allocated(old_items(i)%subset)) then
                    allocate(ctrl%items(i)%subset(size(old_items(i)%subset)))
                    ctrl%items(i)%subset(:) = old_items(i)%subset(:)
                end if
            end do
            deallocate(old_items)
        end if
        write(ctrl%items(size(ctrl%items))%id, '(A,I2.2)') "KPAR", component+1
        if (allocated(ctrl%x)) then
            ctrl%items(size(ctrl%items))%offset = size(ctrl%x)
        else
            ctrl%items(size(ctrl%items))%offset = 0
        end if
        ctrl%items(size(ctrl%items))%nx = ndata

        ! Resize values array
        if (allocated(ctrl%x)) then
            size_old = size(ctrl%x)
        else
            size_old = 0
        end if
        size_new = size_old + ndata
        call alloc_or_realloc_r(ctrl%x, size_new)
        call alloc_or_realloc_r(ctrl%x0, size_new)
            
        ! Set new values
        idata = size_old
        do iseg = 1, msh%nseg
            if (allocated(msh%seg(iseg)%strickler_fields) .and. &
                size(msh%seg(iseg)%strickler_fields) > 0) then
                do i = 1, size(msh%seg(iseg)%strickler_fields(component+1)%x)
                    idata = idata + 1
                    !write(6,*) "test",iseg,i,idata
                    ctrl%x(idata) = msh%seg(iseg)%strickler_fields(component+1)%y(i)
                    ctrl%x0(idata) = msh%seg(iseg)%strickler_fields(component+1)%y(i)
                end do
            else 
                do ics = msh%seg(iseg)%first_cs, msh%seg(iseg)%last_cs
                    idata = idata + 1
                    ctrl%x(idata) = msh%cs(ics)%strickler_params(component+1)
                    ctrl%x0(idata) = msh%cs(ics)%strickler_params(component+1)
                end do
            end if 
        end do
        
    end subroutine


    subroutine add_alpha_floodplain_in_control(ctrl, mdl, msh)
        implicit none
        type(Control), intent(inout) :: ctrl
        type(Model), intent(in) :: mdl
        type(Mesh), intent(in) :: msh

        integer(ip) :: i
        integer(ip) :: ics
        integer(ip) :: idata
        integer(ip) :: iseg
        integer(ip) :: ndata
        integer(ip) :: size_old
        integer(ip) :: size_new
        character(len=6) :: newid
        type(ControlItem), dimension(:), allocatable :: old_items
        
#ifdef FLOODPLAIN_MODEL
        ! Compute number of data
        ndata = 0
        do iseg = 1, msh%nseg
            ndata = ndata + msh%seg(iseg)%last_cs - msh%seg(iseg)%first_cs + 1
        end do
        
        ! Resize items array
        if (allocated(ctrl%items)) then
            size_old = size(ctrl%items)
            allocate(old_items(size(ctrl%items)))
            do i = 1, size(ctrl%items)
                old_items(i)%id = ctrl%items(i)%id
                old_items(i)%nx = ctrl%items(i)%nx
                old_items(i)%offset = ctrl%items(i)%offset
                if (allocated(ctrl%items(i)%subset)) then
                    allocate(old_items(i)%subset(size(ctrl%items(i)%subset)))
                    old_items(i)%subset(:) = ctrl%items(i)%subset(:)
                end if
            end do
            deallocate(ctrl%items)
        else
            size_old = 0
        end if
        allocate(ctrl%items(size_old+1))
        ctrl%nitems = size_old+1
        if (size_old > 0) then
            do i = 1, size_old
                ctrl%items(i)%id = old_items(i)%id
                ctrl%items(i)%nx = old_items(i)%nx
                ctrl%items(i)%offset = old_items(i)%offset
                if (allocated(old_items(i)%subset)) then
                    allocate(ctrl%items(i)%subset(size(old_items(i)%subset)))
                    ctrl%items(i)%subset(:) = old_items(i)%subset(:)
                end if
            end do
            deallocate(old_items)
        end if
        write(ctrl%items(size(ctrl%items))%id, '(A)') "AFP"
        if (allocated(ctrl%x)) then
            ctrl%items(size(ctrl%items))%offset = size(ctrl%x)
        else
            ctrl%items(size(ctrl%items))%offset = 0
        end if
        ctrl%items(size(ctrl%items))%nx = ndata
                
        ! Resize values array
        if (allocated(ctrl%x)) then
            size_old = size(ctrl%x)
        else
            size_old = 0
        end if
        size_new = size_old + ndata
        call alloc_or_realloc_r(ctrl%x, size_new)
        call alloc_or_realloc_r(ctrl%x0, size_new)
        
        ! Set new values
        idata = 0
        do iseg = 1, msh%nseg
            do ics = msh%seg(iseg)%first_cs, msh%seg(iseg)%last_cs
                idata = idata + 1
                ctrl%x(size_old+idata) = msh%cs(ics)%alphaFP
                ctrl%x0(size_old+idata) = msh%cs(ics)%alphaFP
            end do
        end do
#else
        call abort_solver("Model was not compiled with FLOODPLAIN_MODEL flag")
#endif
    
    end subroutine


    integer function get_items_count(ctrl)
        use m_linear_algebra, only: csr_x_vec_add
        implicit none
        type(Control), intent(inout) :: ctrl
        
        ! CHECK-UP
        if (allocated(ctrl%items)) then
            get_items_count = size(ctrl%items)
        else
            get_items_count =  0
        end if
        
    end function


    subroutine get_real_control(ctrl, x)
        use m_linear_algebra, only: csr_x_vec_add
        implicit none
        type(Control), intent(inout) :: ctrl
        real(rp), dimension(:), intent(inout) :: x
        !=LOCAL VARIABLES==============================================================================================!
        ! Index of first value in control vector
        integer(ip) :: first_value
        ! Iterator
        integer(ip) :: i
        ! Index of control item
        integer(ip) :: iitem
        ! Index of cross-section
        integer(ip) :: ics
        ! Index of segment
        integer(ip) :: iseg
        ! Index of strickler parameter
        integer(ip) :: ipar
        ! Index of control value
        integer(ip) :: ivalue
        ! Index of first value in control vector
        integer(ip) :: last_value
        ! Index of boundary condition
        integer(ip) :: ibc
        
        ! CHECK-UP
        if (size(x) /= size(ctrl%x)) then
            call abort_solver("x must be of same size of control")
        end if
        
        if (ctrl%Bdemi%n > 0) then
        
            x(:) = ctrl%x0(:)
            call csr_x_vec_add(ctrl%Bdemi, ctrl%x, x(:))
            
        else
        
            x(:) = ctrl%x(:)
        
        end if
        
    end subroutine


    subroutine get_model_control(ctrl, mdl, x)
        use m_linear_algebra, only: csr_x_vec_add
        use m_numeric, only: linear_interp
        implicit none
        type(Control), intent(inout) :: ctrl
        type(Model), intent(inout) :: mdl
        real(rp), dimension(:), intent(inout) :: x
        !=LOCAL VARIABLES==============================================================================================!
        ! Index of first value in control vector
        integer(ip) :: first_value
        ! Iterator
        integer(ip) :: i
        ! Index of boundary condition
        integer(ip) :: ibc
        ! Index of cross-section
        integer(ip) :: ics
        ! Index of inflow condition
        integer(ip) :: iic
        ! Index of control item
        integer(ip) :: iitem
        ! Index of strickler parameter
        integer(ip) :: ipar
        ! Index of segment
        integer(ip) :: iseg
        ! Index of control value
        integer(ip) :: ivalue
        ! Index of first value in control vector
        integer(ip) :: last_value
        ! Temporary value
        real(rp) :: tmp
        ! Maximum value for a spatial field
        real(rp) :: y_max
        ! Curvilinear abscissae for interpolation
        real(rp), dimension(:), allocatable :: xs
        ! Maximum bathymetry for interpolation
        real(rp), dimension(:), allocatable :: bathy_max
        
        ! Get real control
        call get_real_control(ctrl, x)
    
        ! Loop on control items for range corrections
        do iitem = 1, size(ctrl%items)

            first_value = ctrl%items(iitem)%offset + 1
            last_value = ctrl%items(iitem)%offset + ctrl%items(iitem)%nx

            if (ctrl%items(iitem)%id(1:2) == "BC") then
            
                read(ctrl%items(iitem)%id(3:5), '(I3)') ibc
                
                if (mdl%bc(ibc)%id == "discharge") then
                
                    do i = first_value, last_value
                        x(i) = max(x(i), mdl%qeps)
                    end do
                
                end if

            else if (ctrl%items(iitem)%id(1:2) == "IC") then
            
                read(ctrl%items(iitem)%id(3:5), '(I3)') iic
                
                do i = first_value, last_value
                    x(i) = max(x(i), 0.0)
                end do
        
            else if (ctrl%items(iitem)%id == "BATHY") then
            
                ivalue = first_value
                do iseg = 1, mdl%msh%nseg
                    if (allocated(mdl%msh%seg(iseg)%bathy_field%y)) then
                        
                        ! Compute maximum bathymetry at the cross-sections scale (= level_heights(1) - 1.1 * heps)
                        allocate(xs(mdl%msh%seg(iseg)%last_cs-mdl%msh%seg(iseg)%first_cs+1))
                        allocate(bathy_max(mdl%msh%seg(iseg)%last_cs-mdl%msh%seg(iseg)%first_cs+1))
                        do ics = mdl%msh%seg(iseg)%first_cs, mdl%msh%seg(iseg)%last_cs
                            i = ics - mdl%msh%seg(iseg)%first_cs + 1
                            xs = mdl%msh%cs(ics)%x
                            bathy_max(i) = mdl%msh%cs(ics)%level_heights(1) - 1.1 * mdl%heps
                        end do

                        ! Update control value with maximum bathymetry linearly interpolated at the spatial field scale
                        do i = 1, size(mdl%msh%seg(iseg)%bathy_field%y)
                            x(ivalue) = mdl%msh%seg(iseg)%bathy_field%y(i)
                            y_max = linear_interp(xs, bathy_max, mdl%msh%seg(iseg)%bathy_field%x(i))
                            if (x(ivalue) > y_max) then
                                x(ivalue) = y_max
                            end if
                            ivalue = ivalue + 1
                        end do
                        
                    else
                        do ics = mdl%msh%seg(iseg)%first_cs, mdl%msh%seg(iseg)%last_cs
                            tmp = x(ivalue)
                            if (x(ivalue) > mdl%msh%cs(ics)%level_heights(1) - 1.1 * mdl%heps) then
                                x(ivalue) = mdl%msh%cs(ics)%level_heights(1) - 1.1 * mdl%heps
                            end if
                            ivalue = ivalue + 1
                        end do
                    end if
                end do
                
            end if
            
        end do
        
    end subroutine


    subroutine get_model_control_bounds(ctrl, mdl, xmin, xmax)
        use m_linear_algebra, only: csr_x_vec_add
        implicit none
        type(Control), intent(inout) :: ctrl
        type(Model), intent(inout) :: mdl
        real(rp), dimension(:), intent(inout) :: xmin
        real(rp), dimension(:), intent(inout) :: xmax
        !=LOCAL VARIABLES==============================================================================================!
        ! Index of first value in control vector
        integer(ip) :: first_value
        ! Iterator
        integer(ip) :: i
        ! Index of control item
        integer(ip) :: iitem
        ! Index of cross-section
        integer(ip) :: ics
        ! Index of segment
        integer(ip) :: iseg
        ! Index of strickler parameter
        integer(ip) :: ipar
        ! Index of control value
        integer(ip) :: ivalue
        ! Index of first value in control vector
        integer(ip) :: last_value
        ! Index of boundary condition
        integer(ip) :: ibc
        real(rp) :: tmp
        
        ! Loop on control items for range corrections
        do iitem = 1, size(ctrl%items)

            first_value = ctrl%items(iitem)%offset + 1
            last_value = ctrl%items(iitem)%offset + ctrl%items(iitem)%nx

            if (ctrl%items(iitem)%id(1:2) == "BC") then
            
                read(ctrl%items(iitem)%id(3:5), '(I3)') ibc
                
                if (mdl%bc(ibc)%id == "discharge") then
                
                    do i = first_value, last_value
                        xmin(i) = mdl%qeps
                        xmax(i) = -1e+99_rp
                    end do
                
                end if
        
            else if (ctrl%items(iitem)%id == "BATHY") then
            
                ivalue = first_value
                do iseg = 1, mdl%msh%nseg
                    do ics = mdl%msh%seg(iseg)%first_cs, mdl%msh%seg(iseg)%last_cs
                        xmin(i) = -1e+99_rp
                        xmax(i) = mdl%msh%cs(ics)%level_heights(1) - 1.1 * mdl%heps
                        ivalue = ivalue + 1
                    end do
                end do
                
            else
            
                xmin(i) = -1e+99_rp
                xmax(i) = -1e+99_rp
                
            end if
            
        end do
        
    end subroutine


    subroutine get_control_contributions(ctrl, contribs)
        use m_linear_algebra, only: csr_x_vec_add
        implicit none
        type(Control), intent(inout) :: ctrl
        real(rp), dimension(:, :), intent(inout) :: contribs
        
        real(rp), dimension(size(ctrl%x)) :: x
        integer(ip) :: i
        
        ! CHECK-UP
        if (size(contribs, 1) /= size(ctrl%x) .or. size(contribs, 2) /= size(ctrl%x)) then
            call abort_solver("contribs must be of shape (n,n) where n = size of control")
        end if
        
        if (ctrl%Bdemi%n > 0) then
        
            contribs(:, :) = 0.0_rp
            do i = 1, size(ctrl%x)
                x(:) = 0.0_rp
                x(i) = ctrl%x(i)
                call csr_x_vec_add(ctrl%Bdemi, x, contribs(i, :))
                if (i<4 .or. i == 11)  then
                print *, i, ctrl%x(i), contribs(i, 1:5) 
                print *, "[]", contribs(i, 1:5) * ctrl%x(i)
                end if
            end do
            
        else
        
            contribs(:, :) = 0.0_rp
            do i = 1, size(ctrl%x)
                contribs(i, i) = ctrl%x(i)
            end do
        
        end if
        
    end subroutine


    function temporal_correlation_matrix(ctrl, t, mu) result(mat)
        implicit none
        type(Control), intent(in) :: ctrl
        real(rp), dimension(:), intent(in) :: t
        real(rp), intent(in) :: mu
        type(Matrix) :: mat
        ! Index of downstream cross-section
        integer(ip) :: ds_cs
        ! Iterators on times
        integer(ip) :: it1, it2
        ! Iterator on segments
        integer(ip) :: iseg
        ! Number of data (non ghost cross-sections)
        integer(ip) :: ndata
        ! Index of upstream cross-section
        integer(ip) :: us_cs
        ! Spatial indices (indices of non ghost cross-sections)
        integer(ip), dimension(:), allocatable :: spatial_index
        ! Spacing
        real(rp) :: dx
        ! Correlation value
        real(rp) :: corr
        
        allocate(mat%m(size(t), size(t)))
        mat%m(:, :) = 0.0_rp
        
        ! Compute correlations
        do it1 = 1, size(t)
            do it2 = it1, size(t)
                dt = t(it2) - t(it1)
                corr = exp(-abs(dt) / mu) ! exp kernel
                mat%m(it1, it2) = corr
                mat%m(it2, it1) = corr
            end do
        end do
        
    end function



! ! !     function exponential_correlation_matrix(ctrl, msh, item_index, mu) result(mat)
! ! !         implicit none
! ! !         type(Control), intent(in) :: ctrl
! ! !         type(Mesh), intent(in) :: msh
! ! !         character(len=*), intent(in) :: field
! ! !         real(rp), intent(in) :: mu
! ! !         type(Matrix) :: mat
! ! !         ! Iterators on field points
! ! !         integer(ip) :: i1, i2
! ! !         ! Iterator on segments
! ! !         integer(ip) :: iseg
! ! !         ! Number of data (non ghost cross-sections)
! ! !         integer(ip) :: ndata
! ! !         ! Offset
! ! !         integer(ip) :: offset
! ! !         ! Spacing
! ! !         real(rp) :: dx
! ! !         ! Correlation value
! ! !         real(rp) :: corr
! ! !         
! ! !         
! ! !         if (ctrl%items(item_index)(1:4) == "KPAR") then
! ! !             read(ctrl%items(iitem)%id(5:6), '(I2)') ipar
! ! !             do iseg = 1, msh%nseg
! ! !                 if (allocated(msh%seg(iseg)%strickler_fields)) then
! ! !                     call exponential_correlation_matrix(msh%seg(iseg)%strickler_fields(ipar)%x, &
! ! !                                                         mat%m)
! ! !                 else
! ! !                     allocate(x(msh%seg(iseg)%last_cs - msh%seg(iseg)%first_cs + 1))
! ! !                     allocate(mat%m(msh%seg(iseg)%last_cs - msh%seg(iseg)%first_cs + 1))
! ! !                     do ics = msh%seg(iseg)%first_cs, msh%seg(iseg)%last_cs
! ! !                         x(ics - msh%seg(iseg)%first_cs + 1) = msh%cs(ics)%x
! ! !                     end do
! ! !                     call exponential_correlation_matrix(x, mat%m)
! ! !                         
! ! !                     end do
! ! !                 end if
! ! !             
! ! !         end if
! ! !         
! ! !         ! Compute number of data
! ! !         ndata = 0
! ! !         do iseg = 1, msh%nseg
! ! !             if (field == "K" .or. field == "alpha" .or. field == "KLOB") then
! ! !                 if (.not. allocated(msh%seg(iseg)%strickler_fields)) then
! ! !                     call f90wrap_abort("strickler fields not activated")
! ! !                 end if
! ! !                 ndata = ndata + size(msh%seg(iseg)%strickler_fields(1)%x)
! ! !             else if (field == "beta" .or. field == "KMC") then
! ! !                 if (.not. allocated(msh%seg(iseg)%strickler_fields)) then
! ! !                     call f90wrap_abort("strickler fields not activated")
! ! !                 end if
! ! !                 ndata = ndata + size(msh%seg(iseg)%strickler_fields(2)%x)
! ! !             else if (field == "KLOB") then
! ! !                 if (.not. allocated(msh%seg(iseg)%strickler_fields)) then
! ! !                     call f90wrap_abort("strickler fields not activated")
! ! !                 end if
! ! !                 ndata = ndata + size(msh%seg(iseg)%strickler_fields(3)%x)
! ! !             else if (field == "bathy") then
! ! !                 if (.not. allocated(msh%seg(iseg)%bathy_field%x)) then
! ! !                     call f90wrap_abort("bathymetry field not activated")
! ! !                 end if
! ! !                 ndata = ndata + size(msh%seg(iseg)%bathy_field%x)
! ! !             end if
! ! !         end do
! ! !         
! ! !         allocate(mat%m(ndata, ndata))
! ! !         mat%m(:, :) = 0.0_rp
! ! !         
! ! !         ! Set values on the diagonal
! ! !         do i1 = 1, ndata
! ! !             mat%m(i1, i1) = 1.0_rp
! ! !         end do
! ! !         
! ! !         ! Compute correlations in segments
! ! !         offset = 0
! ! !         do iseg = 1, msh%nseg
! ! !             if (field == "K" .or. field == "alpha" .or. field == "KLOB") then
! ! !                 do i1 = 1, size(msh%seg(iseg)%strickler_fields(1)%x) - 1
! ! !                     do i2 = i1+1, size(msh%seg(iseg)%strickler_fields(1)%x)
! ! !                         dx = msh%seg(iseg)%strickler_fields(1)%x(i1) - msh%seg(iseg)%strickler_fields(1)%x(i2)
! ! !                         corr = exp(-abs(dx) / mu) ! exp kernel
! ! !                         mat%m(offset+i1, offset+i2) = corr
! ! !                         mat%m(offset+i2, offset+i1) = corr
! ! !                     end do
! ! !                 end do
! ! !                 offset = offset + size(msh%seg(iseg)%strickler_fields(1)%x)
! ! !             else if (field == "beta" .or. field == "KMC") then
! ! !                 do i1 = 1, size(msh%seg(iseg)%strickler_fields(2)%x) - 1
! ! !                     do i2 = i1+1, size(msh%seg(iseg)%strickler_fields(2)%x)
! ! !                         dx = msh%seg(iseg)%strickler_fields(2)%x(i1) - msh%seg(iseg)%strickler_fields(2)%x(i2)
! ! !                         corr = exp(-abs(dx) / mu) ! exp kernel
! ! !                         mat%m(offset+i1, offset+i2) = corr
! ! !                         mat%m(offset+i2, offset+i1) = corr
! ! !                     end do
! ! !                 end do
! ! !                 offset = offset + size(msh%seg(iseg)%strickler_fields(2)%x)
! ! !             else if (field == "KROB") then
! ! !                 do i1 = 1, size(msh%seg(iseg)%strickler_fields(3)%x) - 1
! ! !                     do i2 = i1+1, size(msh%seg(iseg)%strickler_fields(3)%x)
! ! !                         dx = msh%seg(iseg)%strickler_fields(3)%x(i1) - msh%seg(iseg)%strickler_fields(1)%x(i2)
! ! !                         corr = exp(-abs(dx) / mu) ! exp kernel
! ! !                         mat%m(offset+i1, offset+i2) = corr
! ! !                         mat%m(offset+i2, offset+i1) = corr
! ! !                     end do
! ! !                 end do
! ! !                 offset = offset + size(msh%seg(iseg)%strickler_fields(3)%x)
! ! !             else if (field == "bathy") then
! ! !                 do i1 = 1, size(msh%seg(iseg)%bathy_field%x) - 1
! ! !                     do i2 = i1+1, size(msh%seg(iseg)%bathy_field%x)
! ! !                         dx = msh%seg(iseg)%bathy_field%x(i1) - msh%seg(iseg)%bathy_field%x(i2)
! ! !                         corr = exp(-abs(dx) / mu) ! exp kernel
! ! !                         mat%m(offset+i1, offset+i2) = corr
! ! !                         mat%m(offset+i2, offset+i1) = corr
! ! !                     end do
! ! !                 end do
! ! !                 offset = offset + size(msh%seg(iseg)%bathy_field%x)
! ! !             end if
! ! !         end do
! ! !         
! ! !     end function


    ! BACKWARD COMPATIBILITY
    function spatial_correlation_matrix(ctrl, msh, mu) result(mat)
        implicit none
!         import mesh_correlation_matrix
!         interface
!             function mesh_correlation_matrix(ctrl, msh, mu) result(mat)
!                 import Control
!                 import Mesh
!                 import rp
!                 import Matrix
!                 implicit none
!                 type(Control), intent(in) :: ctrl
!                 type(Mesh), intent(in) :: msh
!                 real(rp), intent(in) :: mu
!                 type(Matrix) :: mat
!             end function
!         end interface
        type(Control), intent(in) :: ctrl
        type(Mesh), intent(in) :: msh
        real(rp), intent(in) :: mu
        type(Matrix) :: mat
        mat = mesh_correlation_matrix(ctrl, msh, mu)
    end function

    function mesh_correlation_matrix(ctrl, msh, mu) result(mat)
        implicit none
        type(Control), intent(in) :: ctrl
        type(Mesh), intent(in) :: msh
        real(rp), intent(in) :: mu
        type(Matrix) :: mat
        ! Index of downstream cross-section
        integer(ip) :: ds_cs
        ! Iterators on cross-sections
        integer(ip) :: ics, ics1, ics2
        ! Iterator on segments
        integer(ip) :: iseg
        ! Number of data (non ghost cross-sections)
        integer(ip) :: ndata
        ! Index of upstream cross-section
        integer(ip) :: us_cs
        ! Spatial indices (indices of non ghost cross-sections)
        integer(ip), dimension(:), allocatable :: spatial_index
        ! Spacing
        real(rp) :: dx
        ! Correlation value
        real(rp) :: corr
        
        allocate(spatial_index(size(msh%cs)))
        
        ! Compute spatial indices (indices of non ghost cross-sections)
        ndata = 0
        spatial_index(:) = 0
        do iseg = 1, msh%nseg
            do ics = msh%seg(iseg)%first_cs, msh%seg(iseg)%last_cs
!                 TODO how to have only base sections in control ? Probleme => linear interpolation at resample css ?
!                 if (msh%cs(ics)%ibase > 0) then
!                     ndata = ndata + 1
!                     spatial_index(ics) = ndata
!                 end if
                ndata = ndata + 1
                spatial_index(ics) = ndata
            end do
        end do
        
        allocate(mat%m(ndata, ndata))
        mat%m(:, :) = 0.0_rp
        
        ! Set values on the diagonal
        do ics = 1, msh%ncs
            if (spatial_index(ics) > 0) then
                mat%m(spatial_index(ics), spatial_index(ics)) = 1.0_rp
            end if
        end do
        
        ! Compute correlations in segments
        do iseg = 1, msh%nseg
            do ics1 = msh%seg(iseg)%first_cs, msh%seg(iseg)%last_cs-1
                do ics2 = ics1+1, msh%seg(iseg)%last_cs-1
                    if (spatial_index(ics1) > 0 .and. spatial_index(ics2) > 0) then
                        dx = msh%cs(ics1)%x - msh%cs(ics2)%x
                        corr = exp(-abs(dx) / mu) ! exp kernel
                        mat%m(spatial_index(ics1), spatial_index(ics2)) = corr
                        mat%m(spatial_index(ics2), spatial_index(ics1)) = corr
                    end if
                end do
!                 if (abs(mat%m(ics, ics+1)) < 1e-99) mat%m(ics, ics+1) = 0.0_rp
!                 mat%m(spatial_index(ics+1), spatial_index(ics)) = mat%m(spatial_index(ics), spatial_index(ics+1))
            end do
        end do
        
        ! Compute correlations in junctions
        do iseg = 1, msh%nseg
            if (msh%seg(iseg)%ds_seg > 0) then
                ds_cs = msh%seg(iseg)%last_cs
                us_cs = msh%seg(msh%seg(iseg)%ds_seg)%first_cs
                mat%m(spatial_index(ds_cs), spatial_index(us_cs)) = 1.0_rp
                mat%m(spatial_index(us_cs), spatial_index(ds_cs)) = 1.0_rp
            end if
        end do
        
        deallocate(spatial_index)
        
    end function


    function field_correlation_matrix(ctrl, msh, field, mu) result(mat)
        implicit none
        type(Control), intent(in) :: ctrl
        type(Mesh), intent(in) :: msh
        character(len=*), intent(in) :: field
        real(rp), intent(in) :: mu
        type(Matrix) :: mat
        ! Iterators on field points
        integer(ip) :: i1, i2
        ! Iterator on segments
        integer(ip) :: iseg
        ! Number of data (non ghost cross-sections)
        integer(ip) :: ndata
        ! Offset
        integer(ip) :: offset
        ! Spacing
        real(rp) :: dx
        ! Correlation value
        real(rp) :: corr
        
        ! Compute number of data
        ndata = 0
        do iseg = 1, msh%nseg
            if (field == "K" .or. field == "alpha" .or. field == "KLOB") then
                if (.not. allocated(msh%seg(iseg)%strickler_fields)) then
!                     call f90wrap_abort("strickler fields not activated")
                    mat = mesh_correlation_matrix(ctrl, msh, mu)
                    return 
                end if
                ndata = ndata + size(msh%seg(iseg)%strickler_fields(1)%x)
            else if (field == "beta" .or. field == "KMC") then
                if (.not. allocated(msh%seg(iseg)%strickler_fields)) then
!                     call f90wrap_abort("strickler fields not activated")
                    mat = mesh_correlation_matrix(ctrl, msh, mu)
                    return 
                end if
                ndata = ndata + size(msh%seg(iseg)%strickler_fields(2)%x)
            else if (field == "KROB") then
                if (.not. allocated(msh%seg(iseg)%strickler_fields)) then
!                     call f90wrap_abort("strickler fields not activated")
                    mat = mesh_correlation_matrix(ctrl, msh, mu)
                    return 
                end if
                ndata = ndata + size(msh%seg(iseg)%strickler_fields(3)%x)
            else if (field == "bathy") then
                if (.not. allocated(msh%seg(iseg)%bathy_field%x)) then
!                     call f90wrap_abort("bathymetry field not activated")
                    mat = mesh_correlation_matrix(ctrl, msh, mu)
                    return 
                end if
                ndata = ndata + size(msh%seg(iseg)%bathy_field%x)
            end if
        end do
        
        allocate(mat%m(ndata, ndata))
        mat%m(:, :) = 0.0_rp
        
        ! Set values on the diagonal
        do i1 = 1, ndata
            mat%m(i1, i1) = 1.0_rp
        end do
        
        ! Compute correlations in segments
        offset = 0
        do iseg = 1, msh%nseg
            if (field == "K" .or. field == "alpha" .or. field == "KLOB") then
                do i1 = 1, size(msh%seg(iseg)%strickler_fields(1)%x) - 1
                    do i2 = i1+1, size(msh%seg(iseg)%strickler_fields(1)%x)
                        dx = msh%seg(iseg)%strickler_fields(1)%x(i1) - msh%seg(iseg)%strickler_fields(1)%x(i2)
                        corr = exp(-abs(dx) / mu) ! exp kernel
                        mat%m(offset+i1, offset+i2) = corr
                        mat%m(offset+i2, offset+i1) = corr
                    end do
                end do
                offset = offset + size(msh%seg(iseg)%strickler_fields(1)%x)
            else if (field == "beta" .or. field == "KMC") then
                do i1 = 1, size(msh%seg(iseg)%strickler_fields(2)%x) - 1
                    do i2 = i1+1, size(msh%seg(iseg)%strickler_fields(2)%x)
                        dx = msh%seg(iseg)%strickler_fields(2)%x(i1) - msh%seg(iseg)%strickler_fields(2)%x(i2)
                        corr = exp(-abs(dx) / mu) ! exp kernel
                        mat%m(offset+i1, offset+i2) = corr
                        mat%m(offset+i2, offset+i1) = corr
                    end do
                end do
                offset = offset + size(msh%seg(iseg)%strickler_fields(2)%x)
            else if (field == "KROB") then
                do i1 = 1, size(msh%seg(iseg)%strickler_fields(3)%x) - 1
                    do i2 = i1+1, size(msh%seg(iseg)%strickler_fields(3)%x)
                        dx = msh%seg(iseg)%strickler_fields(3)%x(i1) - msh%seg(iseg)%strickler_fields(1)%x(i2)
                        corr = exp(-abs(dx) / mu) ! exp kernel
                        mat%m(offset+i1, offset+i2) = corr
                        mat%m(offset+i2, offset+i1) = corr
                    end do
                end do
                offset = offset + size(msh%seg(iseg)%strickler_fields(3)%x)
            else if (field == "bathy") then
                do i1 = 1, size(msh%seg(iseg)%bathy_field%x) - 1
                    do i2 = i1+1, size(msh%seg(iseg)%bathy_field%x)
                        dx = msh%seg(iseg)%bathy_field%x(i1) - msh%seg(iseg)%bathy_field%x(i2)
                        corr = exp(-abs(dx) / mu) ! exp kernel
                        mat%m(offset+i1, offset+i2) = corr
                        mat%m(offset+i2, offset+i1) = corr
                    end do
                end do
                offset = offset + size(msh%seg(iseg)%bathy_field%x)
            end if
        end do
        
    end function


    function spatial_correlation_matrix_gaussian(ctrl, msh, mu) result(mat)
        implicit none
        type(Control), intent(in) :: ctrl
        type(Mesh), intent(in) :: msh
        real(rp), intent(in) :: mu
        type(Matrix) :: mat
        ! Index of downstream cross-section
        integer(ip) :: ds_cs
        ! Iterators on cross-sections
        integer(ip) :: ics, ics1, ics2
        ! Iterator on segments
        integer(ip) :: iseg
        ! Number of data (non ghost cross-sections)
        integer(ip) :: ndata
        ! Index of upstream cross-section
        integer(ip) :: us_cs
        ! Spatial indices (indices of non ghost cross-sections)
        integer(ip), dimension(:), allocatable :: spatial_index
        ! Spacing
        real(rp) :: dx
        ! Correlation value
        real(rp) :: corr
        real(rp), parameter :: PI = 4._rp * atan(1._rp)
        
        allocate(spatial_index(size(msh%cs)))
        
        ! Compute spatial indices (indices of non ghost cross-sections)
        ndata = 0
        spatial_index(:) = 0
        do iseg = 1, msh%nseg
            do ics = msh%seg(iseg)%first_cs, msh%seg(iseg)%last_cs
                ndata = ndata + 1
                spatial_index(ics) = ndata
            end do
        end do
        
        allocate(mat%m(ndata, ndata))
        mat%m(:, :) = 0.0_rp
        
        ! Set values on the diagonal
        do ics = 1, msh%ncs
            if (spatial_index(ics) > 0) then
                mat%m(spatial_index(ics), spatial_index(ics)) = 1.0 / (mu * 2.0 * PI)
            end if
        end do
        
        ! Compute correlations in segments
        do iseg = 1, msh%nseg
            do ics1 = msh%seg(iseg)%first_cs, msh%seg(iseg)%last_cs-1
                do ics2 = ics1+1, msh%seg(iseg)%last_cs-1
                    dx = msh%cs(ics1)%x - msh%cs(ics2)%x
                    corr = 1.0 / (mu * 2.0 * PI) *  exp(-0.5 * (dx / mu)**2) ! exp kernel
                    mat%m(spatial_index(ics1), spatial_index(ics2)) = corr
                    mat%m(spatial_index(ics2), spatial_index(ics1)) = corr
                end do
!                 if (abs(mat%m(ics, ics+1)) < 1e-99) mat%m(ics, ics+1) = 0.0_rp
!                 mat%m(spatial_index(ics+1), spatial_index(ics)) = mat%m(spatial_index(ics), spatial_index(ics+1))
            end do
        end do
        
        ! Compute correlations in junctions
        do iseg = 1, msh%nseg
            if (msh%seg(iseg)%ds_seg > 0) then
                ds_cs = msh%seg(iseg)%last_cs
                us_cs = msh%seg(msh%seg(iseg)%ds_seg)%first_cs
                mat%m(spatial_index(ds_cs), spatial_index(us_cs)) = 1.0_rp
                mat%m(spatial_index(us_cs), spatial_index(ds_cs)) = 1.0_rp
            end if
        end do
        
        deallocate(spatial_index)
        
    end function
    

  function calc_cost_reg(ctrl,msh)result(cost_ctrl)
      type(Control), intent(inout) :: ctrl
      type(Mesh), intent(in) :: msh
      real(rp) :: cost_ctrl
      integer(ip) :: ics,icsm,icsp

     !!!  terme de reg => gradient de la bathy
     ics = msh%seg(1)%first_cs
     cost_ctrl = ( ( msh%cs(ics+1)%bathy-msh%cs(ics)%bathy ) / ( msh%cs(ics+1)%deltademi ) )**2
     do ics = msh%seg(1)%first_cs+1, msh%seg(1)%last_cs-1
         cost_ctrl = cost_ctrl + ( ( msh%cs(ics+1)%bathy-msh%cs(ics-1)%bathy ) / ( 2*msh%cs(ics)%deltademi ) )**2     
     end do
     ics = msh%seg(1)%last_cs
     cost_ctrl = cost_ctrl + ( ( msh%cs(ics)%bathy-msh%cs(ics-1)%bathy ) / ( msh%cs(ics)%deltademi ) )**2

    !!!  terme de reg => gradient de la bathy-bathy background
    !if (ctrl%Bdemi%n > 0) then
    !  ics = msh%seg(1)%first_cs
    !  cost_ctrl = ( (ctrl%x(2)-ctrl%x(1)) / msh%cs(ics+1)%deltademi )**2
    !  do ics = msh%seg(1)%first_cs+1, msh%seg(1)%last_cs-1
    !      cost_ctrl=cost_ctrl+((ctrl%x(ics-msh%seg(1)%first_cs+2)-ctrl%x(ics-msh%seg(1)%first_cs))/(2*msh%cs(ics)%deltademi))**2     
    !  end do
    !  ics = msh%seg(1)%last_cs
    !  cost_ctrl=cost_ctrl+((ctrl%x(ics-msh%seg(1)%first_cs+1)-ctrl%x(ics-msh%seg(1)%first_cs))/(msh%cs(ics)%deltademi))**2 
    !  else
    !      ics = msh%seg(1)%first_cs
    !      cost_ctrl = ( ((ctrl%x(2)-ctrl%x0(2))-(ctrl%x(1)-ctrl%x0(1))) / msh%cs(ics+1)%deltademi )**2
    !      do ics = msh%seg(1)%first_cs+1, msh%seg(1)%last_cs-1
    !          icsp = ics-msh%seg(1)%first_cs+2
    !          icsm = ics-msh%seg(1)%first_cs
    !          cost_ctrl=cost_ctrl+((ctrl%x(icsp)-ctrl%x0(icsp)-ctrl%x(icsm)+ctrl%x0(icsm))/(2*msh%cs(ics)%deltademi))**2     
    !      end do
    !      ics = msh%seg(1)%last_cs
    !      icsp = ics-msh%seg(1)%first_cs+1
    !      icsm = ics-msh%seg(1)%first_cs
    !      cost_ctrl=cost_ctrl+((ctrl%x(icsp)-ctrl%x0(icsp)-ctrl%x(icsm)+ctrl%x0(icsm))/(msh%cs(ics)%deltademi))**2          
    !  end if

    !!! terme de reg => ecart au background
    !if (ctrl%Bdemi%n > 0) then
    !    cost_ctrl = sum((ctrl%x(:))**2)  
    !else
    !    cost_ctrl = sum((ctrl%x(:) - ctrl%x0(:))**2)
    !end if 

    cost_ctrl = ctrl%coef_reg*cost_ctrl
  end function


#endif
end module m_control
