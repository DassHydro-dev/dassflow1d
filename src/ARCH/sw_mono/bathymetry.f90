!======================================================================================================================!
!
!                    DassFlow Version 2.0
!
!======================================================================================================================!
!
!  Copyright University of Toulouse-INSA - CNRS (France)
!
!  This file is part of the DassFlow software (Data Assimilation for Free Surface Flows).
!  DassFlow is a computational software aiming at simulating geophysical free surface flows.
!  It is designed for Variational Data Assimilation (4D-var) and sensitivity analyses. 
! Inverse capabilities are based on the adjoint code which is generated by 
! a source-to-source algorithmic differentiation (Tapenade software used).
!
!  DassFlow software includes few mostly independent "modules" with common architectures and structures:
!    - DassFlow 2DShallow (shallow water equations in (h,q), finite volumes), i.e. the present code.
!    - DassFlow3D  (non-linear Stokes equations, finite elements, mobile geometries, ALE).
!    - DassFlow 1D (shallow water equations in (S,Q), finite volumes or finite differences), river hydraulics.
!  Please consult the DassFlow webpage for more details: http://www.math.univ-toulouse.fr/DassFlow
!
! You have used DassFlow in an article, a scientific document etc ?  How to cite us ? Please consult the webpage.
! 
!  Many people have contributed to the DassFlow developments from the initial version to the latest ones.
!  Current main developers or scientific contributers are:
!               P. Brisset (CNES & Mathematics Institute of Toulouse & INSA Toulouse)
!               F. Couderc (CNRS & Mathematics Institute of Toulouse IMT)
!               P.-A. Garambois (INSA & ICUBE Strasbourg)
!               J. Monnier (INSA & Mathematics Institute of Toulouse IMT).
!               J.-P. Vila (INSA & Mathematics Institute of Toulouse IMT).
!  and former other developers (R. Madec, M. Honnorat and J. Marin).
!
!  Scientific contact : jerome.monnier@insa-toulouse.fr
!  Technical  contacts : frederic.couderc@math.univ-toulouse.fr, pierre.brisset@insa-toulouse.fr
!
!  This software is governed by the CeCILL license under French law and abiding by the rules of distribution
!  of free software. You can use, modify and/or redistribute the software under the terms of the CeCILL license
!  as circulated by CEA, CNRS and INRIA at the following URL: "http://www.cecill.info".
!
!  As a counterpart to the access to the source code and rights to copy, modify and redistribute granted by the
!  license, users are provided only with a limited warranty and the software's author, the holder of the economic
!  rights, and the successive licensors have only limited liability.
!
!  In this respect, the user's attention is drawn to the risks associated with loading, using, modifying and/or
!  developing or reproducing the software by the user in light of its specific status of free software, that may
!  mean that it is complicated to manipulate, and that also therefore means that it is reserved for developers and
!  experienced professionals having in-depth computer knowledge. Users are therefore encouraged to load and test the
!  software's suitability as regards their requirements in conditions enabling the security of their systems and/or
!  data to be ensured and, more generally, to use and operate it in the same conditions as regards security.
!
!  The fact that you are presently reading this means that you have had knowledge of the CeCILL license and that you
!  accept its terms.
!
!======================================================================================================================!
!> \file bathymetry.f90
!! \brief This file includes the computation/update of bathymetry

!**********************************************************************************************************************!
!**********************************************************************************************************************!
!
!  Compute/update bathymetry
!
!**********************************************************************************************************************!
!**********************************************************************************************************************!

!>  Compute/update bathymetry and update dof values
!!
!! \details This subroutine compute the bathymetry and update the dof values accordingly
!! \param[in]    msh Mesh of the problem.
!! \param[in]    dof Unknowns of the model.
SUBROUTINE calc_bathymetry(msh, dof)

   USE m_mesh
   USE m_model
   USE m_numeric
   USE m_user_data
   USE m_obs
!    USE m_adjoint, only : ite_min
!    USE m_minimization, only : ite_line_search

   implicit none

   !===================================================================================================================!
   !  Interface Variables
   !===================================================================================================================!

   type(Mesh), intent(inout)  ::  msh

   type( unk ), intent(inout)  ::  dof
   

   real(rp) :: HtoS
   real(rp) :: dx, dy, norm
   real(rp) :: z, slopemean, alpha_bathy, offset
   real(rp) :: D, D_ref, h_ref, D_ref_left, D_ref_right, h_ref_left, h_ref_right
   real(rp) :: h_test, h_test_tmp
   integer(ip) :: t_minh_idx
   integer(ip) :: iobs_ref, iobs_ref_left, iobs_ref_right
   integer(ip) :: tmptest
   real(rp), dimension(msh%ncs+4) :: bathy_tmp

   real(rp) :: wi,wim1,Hi,Him1,yi !temporary variable 
   
   character(len=64) :: filename
   
   real(rp) :: GetWFromH
   
   !======================================================================================================================!
   !  Begin Subroutine
   !======================================================================================================================!

   !===================================================================================================================!
   !  Bathymetry must not be higher than H0
   !===================================================================================================================!

   select case( bathymetry )

   !===================================================================================================================!
   !  Inflow Boundary  :  'discharg'
   !===================================================================================================================!

      case('parametric')
      
        if (c_bathy == 1) then
          bathy_cell(3:msh%ncs+2) = bathy_points(:)
        end if
      
        !===================================================================================================================!
        ! Compute mean slope
        !===================================================================================================================!
        bathy_step = 1
        slopemean = 0.0_rp
        do i = 3, msh%ncs+1
            dx = msh%cs(i+1)%coord%x - msh%cs(i)%coord%x
            dy = msh%cs(i+1)%coord%y - msh%cs(i)%coord%y
            slopemean = slopemean + (bathy_cell(i+1) - bathy_cell(i)) / sqrt(dx**2 + dy**2)
        end do
        slopemean = slopemean / real(msh%ncs-1)
        
        do i = 3, msh%ncs+1
            if (bathy_cell(i) > msh%cs(i)%height(1) - 1.1 * heps) then
              !<NOADJ
!               print *, "correction bathy!!", i, bathy_cell(i), msh%cs(i)%height(1) - 1.1 * heps
              !>NOADJ
              bathy_cell(i) = msh%cs(i)%height(1) - 1.1 * heps
            end if
        end do
        msh%cs(msh%ncs+2)%slope = -slopemean
        
        !===================================================================================================================!
        ! Update bathymetry and dof of ghost cells
        !===================================================================================================================!
        bathy_cell(1) = bathy_cell(3)-msh%cs(4)%deltademi*slopemean*2._rp
        bathy_cell(1) = min(msh%cs(1)%height(1) - 1.1 * heps, bathy_cell(1))
        bathy_cell(2) = bathy_cell(3)-msh%cs(4)%deltademi*slopemean
        bathy_cell(2) = min(msh%cs(1)%height(1) - 1.1 * heps, bathy_cell(2))
        bathy_cell(msh%ncs+3) = bathy_cell(msh%ncs+2)+msh%cs(msh%ncs+1)%deltademi*slopemean
        bathy_cell(msh%ncs+3) = min(msh%cs(msh%ncs+3)%height(1) - 1.1 * heps, bathy_cell(msh%ncs+3))
        bathy_cell(msh%ncs+4) = bathy_cell(msh%ncs+2)+msh%cs(msh%ncs+1)%deltademi*slopemean*2._rp
        bathy_cell(msh%ncs+4) = min(msh%cs(msh%ncs+4)%height(1) - 1.1 * heps, bathy_cell(msh%ncs+4))
          
        !<NOADJ
          write(filename,'(A)') "internal_bathy_parametric"
          open(12, file=filename, form='formatted')
          do i=1,msh%ncs+4
             write(12,*) msh%cs(i)%coord%x, bathy_cell(i)
          end do
          close(12)
        !>NOADJ
        
      case('piecewise_constant')
      
         do i = 1, size(bathy_indices) - 1
            do j = bathy_indices(i), bathy_indices(i+1)
               bathy_cell(j) = bathy_points(i)
               if (bathy_cell(j) > msh%cs(j)%height(1) - 1.1 * heps) then
                  bathy_cell(j) = msh%cs(j)%height(1) - 1.1 * heps
               end if
            end do
         end do
         do j = 1, bathy_indices(1)-1
            bathy_cell(j) = bathy_points(1)
            if (bathy_cell(j) > msh%cs(j)%height(1) - 1.1 * heps) then
               bathy_cell(j) = msh%cs(j)%height(1) - 1.1 * heps
            end if
         end do

         ! Interpolate bathy pts after the last bathy control pt using the mean slope
         do j = bathy_indices(size(bathy_indices))+1, msh%ncs+2
            bathy_cell(j) = bathy_points(size(bathy_indices))
            if (bathy_cell(j) > msh%cs(j)%height(1) - 1.1 * heps) then
               bathy_cell(j) = msh%cs(j)%height(1) - 1.1 * heps
            end if
         end do
        
      case('piecewise_linear')
      
         do i = 1, size(bathy_indices) - 1
            dx = msh%cs(bathy_indices(i+1))%coord%x - &
                msh%cs(bathy_indices(i))%coord%x
            norm = sqrt(dx**2)
            do j = bathy_indices(i), bathy_indices(i+1)
               dx = msh%cs(j)%coord%x - msh%cs(bathy_indices(i))%coord%x
               alpha_bathy = sqrt(dx**2) / norm
               bathy_cell(j) = bathy_points(i) + alpha_bathy * (bathy_points(i+1) - bathy_points(i))
               if (bathy_cell(j) > msh%cs(j)%height(1) - 1.1 * heps) then
                  bathy_cell(j) = msh%cs(j)%height(1) - 1.1 * heps
               end if
            end do
         end do
            
         ! Compute mean slope
         slopemean = 0.0_rp
         do i = bathy_indices(1), bathy_indices(size(bathy_indices)) - 1
            dx = msh%cs(i+1)%coord%x - msh%cs(i)%coord%x
            slopemean = slopemean + (bathy_cell(i+1) - bathy_cell(i)) / sqrt(dx**2)
         end do
         slopemean = slopemean / (bathy_indices(size(bathy_indices)) - bathy_indices(1))
         
         ! Interpolate bathy pts before the first bathy control pt using the mean slope
         do j = 3, bathy_indices(1)
            dx = msh%cs(j)%coord%x - msh%cs(bathy_indices(1))%coord%x
            bathy_cell(j) = bathy_points(1) - slopemean * sqrt(dx**2)
            if (bathy_cell(j) > msh%cs(j)%height(1) - 1.1 * heps) then
               bathy_cell(j) = msh%cs(j)%height(1) - 1.1 * heps
            end if
         end do
         ! 1st ghost cells
         bathy_cell(1) = bathy_cell(3)-(msh%cs(3)%deltademi+msh%cs(2)%deltademi)*slopemean
         bathy_cell(2) = bathy_cell(3)-msh%cs(3)%deltademi*slopemean

         ! Interpolate bathy pts after the last bathy control pt using the mean slope
         do j = bathy_indices(size(bathy_indices))+1, msh%ncs+2
            dx = msh%cs(j)%coord%x - msh%cs(bathy_indices(size(bathy_indices)))%coord%x
            bathy_cell(j) = bathy_points(size(bathy_points)) + slopemean * sqrt(dx**2)
            if (bathy_cell(j) > msh%cs(j)%height(1) - 1.1 * heps) then
               bathy_cell(j) = msh%cs(j)%height(1) - 1.1 * heps
            end if
         end do
         ! last ghost cells
         bathy_cell(msh%ncs+3) = bathy_cell(msh%ncs+2)+msh%cs(msh%ncs+3)%deltademi*slopemean
         bathy_cell(msh%ncs+4) = bathy_cell(msh%ncs+2)+&
              (msh%cs(msh%ncs+3)%deltademi+msh%cs(msh%ncs+4)%deltademi)*slopemean
         
        !<NOADJ
          open(12, file='bathy_linear.txt', form='formatted')
          do i=1,msh%ncs+4
             write(12,*) bathy_cell(i)
          end do
          close(12)
        !>NOADJ
        
      case('constant_slope')
      
        !===================================================================================================================!
        ! Compute mean slope
         !===================================================================================================================!
         bathy_first = 3
         bathy_last = 3
         bathy_step = 1
        dx = msh%cs(msh%ncs+2)%coord%x - msh%cs(3)%coord%x
        dy = msh%cs(msh%ncs+2)%coord%y - msh%cs(3)%coord%y
        slopemean = (bathy_cell(msh%ncs+2) - bathy_cell(3)) / sqrt(dx**2 + dy**2)
        
        do j = 4, msh%ncs+1
          dx = msh%cs(j)%coord%x - msh%cs(3)%coord%x
          dy = msh%cs(j)%coord%y - msh%cs(3)%coord%y
          bathy_cell(j) = bathy_cell(3) + slopemean * sqrt(dx**2 + dy**2)
        end do
        bathy_cell(1) = bathy_cell(3)-msh%cs(4)%deltademi*slopemean*2._rp
        bathy_cell(2) = bathy_cell(3)-msh%cs(4)%deltademi*slopemean
        bathy_cell(msh%ncs+3) = bathy_cell(msh%ncs+2)+msh%cs(msh%ncs+1)%deltademi*slopemean
        bathy_cell(msh%ncs+4) = bathy_cell(msh%ncs+2)+msh%cs(msh%ncs+1)%deltademi*slopemean*2._rp
        
      case('offset')
         
!          offset = bathy_cell(bathy_first) - msh%cs(bathy_first)%bathy
         offset = bathy_cell(bathy_first+bathy_step) - msh%cs(bathy_first+bathy_step)%bathy
         do j = 1, bathy_first
            z = bathy_cell(j)
            if (j == bathy_first+bathy_step) cycle
            bathy_cell(j) = msh%cs(j)%bathy + offset
            if (bathy_cell(j) > msh%cs(j)%height(1)) then
               bathy_cell(j) = z
            end if
         end do
         offset = bathy_cell(bathy_first+bathy_step) - msh%cs(bathy_first+bathy_step)%bathy
!          do j = bathy_first+1, msh%ncs+4
         do j = 1, msh%ncs+4
            z = bathy_cell(j)
            if (j == bathy_first+bathy_step) cycle
            bathy_cell(j) = msh%cs(j)%bathy + offset
            if (bathy_cell(j) > msh%cs(j)%height(1)) then
               bathy_cell(j) = z
            end if
         end do
      
         
!          offset = bathy_cell(bathy_first) - msh%cs(bathy_first)%bathy
!          do j = 1, bathy_last
!             z = bathy_cell(j)
!             if (j == bathy_first) cycle
!             bathy_cell(j) = msh%cs(j)%bathy + offset
!             if (bathy_cell(j) > msh%cs(j)%height(1)) then
!                bathy_cell(j) = z
!             end if
!          end do
!          offset = bathy_cell(bathy_last) - msh%cs(bathy_last)%bathy
!          do j = bathy_last+1, msh%ncs+4
!             z = bathy_cell(j)
!             if (j == bathy_last) cycle
!             bathy_cell(j) = msh%cs(j)%bathy + offset
!             if (bathy_cell(j) > msh%cs(j)%height(1)) then
!                bathy_cell(j) = z
!             end if
!          end do
      

      !===================================================================================================================!
      ! Propagating bathymetry with Low Froude/constant K assumptions
      !===================================================================================================================!
      ! /!\ Hyp pour ce cas : une station toutes les cs, bathy_first = 1e ref, control tous les bathy_first + k*bathy_step, propagation en amont des pts de ref
      case('low_froude')
         !print*, 'propagate bathy with low froude model'
         ! Find suitable water surface profile (min, mean ...? => for now min)
         h_test = hugem
         do i = 1,SIZE(station(1)%h_bathy) ! time
            do iobs = 1, msh%ncs             ! space
               h_test_tmp = h_test_tmp + station(iobs)%h_bathy(i)
            end do
               h_test_tmp = h_test_tmp / msh%ncs 
            if ( h_test_tmp < h_test ) then
               h_test = h_test_tmp
               t_minh_idx = i
            end if
         end do
         !print*, 'idx t_obs', t_minh_idx
         
         ! "upstream" bathy_first
         iobs_ref = bathy_first - 2
         ! Coeffs of observed quantities: D = W*sqrt(slope)
         D_ref = station(iobs_ref)%w(t_minh_idx)*SQRT(station(iobs_ref)%slope(t_minh_idx))
         ! height corresponding to bathy infered
         h_ref = station(iobs_ref)%h_bathy(t_minh_idx) - bathy_cell(bathy_first)
         do j = 3, bathy_first-1
            ! Find corresponding stations
            iobs = j - 2
            D = station(iobs)%w(t_minh_idx)*SQRT(station(iobs)%slope(t_minh_idx))
            ! Computes bathy
            bathy_cell(j) = station(iobs)%h_bathy(t_minh_idx) - h_ref*D_ref**(0.6_rp)*D**(-0.6_rp) ! zb(x) = H(x) - href*D_ref^(3/5)*D(x)^(-3/5)
            ! Check if bathy does not match the geometry
            if (bathy_cell(j) > msh%cs(j)%height(1)) then
               print*, 'upstream, zb>h0' !NOADJ
               bathy_cell(j) = msh%cs(j)%height(1)-0.01
            end if
         end do

         ! between bathy_first and bathy last
         if ( bathy_first /= bathy_last ) then
            do i = bathy_first+bathy_step, bathy_last, bathy_step
               iobs_ref = i-2
               D_ref = station(iobs_ref)%w(t_minh_idx)*SQRT(station(iobs_ref)%slope(t_minh_idx))
               h_ref = station(iobs_ref)%h_bathy(t_minh_idx) - bathy_cell(i)
               do j = i-bathy_step+1, i-1
                  iobs = j-2
                  z = bathy_cell(j)
                  D = station(iobs)%w(t_minh_idx)*SQRT(station(iobs)%slope(t_minh_idx))
                  bathy_cell(j) = station(iobs)%h_bathy(t_minh_idx) - h_ref*D_ref**(0.6_rp)*D**(-0.6_rp)
                  if (bathy_cell(j) > msh%cs(j)%height(1)) then
                     print*, 'btw ref pts, zb>h0'   !NOADJ
                     bathy_cell(j) = msh%cs(j)%height(1)-0.01
                  end if
               end do
            end do
         end if

         ! "downstream" last_bathy
         iobs_ref = bathy_last-2
         D_ref = station(iobs_ref)%w(t_minh_idx)*SQRT(station(iobs_ref)%slope(t_minh_idx))
         h_ref = station(iobs_ref)%h_bathy(t_minh_idx) - bathy_cell(bathy_last)
         do j = bathy_last+1, msh%ncs+2
            iobs = j-2
            D = station(iobs)%w(t_minh_idx)*SQRT(station(iobs)%slope(t_minh_idx))
            bathy_cell(j) = station(iobs)%h_bathy(t_minh_idx) - h_ref*D_ref**(0.6_rp)*D**(-0.6_rp)
            if (bathy_cell(j) > msh%cs(j)%height(1)) then
               print*, 'downstream, zb>h0'    !NOADJ
               bathy_cell(j) = msh%cs(j)%height(1)-0.01
            end if
         end do


         ! Ghost cells E
         slopemean = 0.0_rp
         do i = 3, msh%ncs+1
            slopemean = slopemean + (bathy_cell(i+1) - bathy_cell(i)) / msh%cs(i+1)%deltademi
         end do
         slopemean = slopemean / real(msh%ncs-1)
         bathy_cell(1) = bathy_cell(3)-(msh%cs(3)%deltademi+msh%cs(2)%deltademi)*slopemean
         bathy_cell(2) = bathy_cell(3)-msh%cs(3)%deltademi*slopemean
         ! Ghost cells W
         bathy_cell(msh%ncs+3) = bathy_cell(msh%ncs+2)+msh%cs(msh%ncs+3)%deltademi*slopemean
         bathy_cell(msh%ncs+4) = bathy_cell(msh%ncs+2)+&
              (msh%cs(msh%ncs+3)%deltademi+msh%cs(msh%ncs+4)%deltademi)*slopemean
         !<NOADJ
         ! TMP, to see all the bathy cells (ghost included)
          open(12, file='bathy_LF.txt', form='formatted')
          do i=1,msh%ncs+4
             write(12,*) bathy_cell(i)
          end do
          close(12)
         !>NOADJ

          
      case default
      
         write (*,'(A31)') 'W bathymetry model not defined' !NOADJ

      end select
  
! DEPRECATED
!    !===================================================================================================================!
!    !  Recomputation of sum of area surface
!    !===================================================================================================================!
!    do i = 1,msh%ncs+4
!       k=msh%cs(i)%nc
! 
!       !TODO : Verifier coherence des donneess
!       !s_0=(H_0-z_b)*w_0
!       msh%cs(i)%surfaceArea(1)      =(msh%cs(i)%height(1)-bathy_cell(i))* & !(H_0-z_b)*
!                                                 msh%cs(i)%surfacewidth(1)              !w_0
!       msh%cs(i)%surfaceAreaSum(1)   =msh%cs(i)%surfaceArea(1)               !S_0=s_0
! 
!       
!       do j=2,k
!          !S_m=0.5*(w_{m-1}+w_{m})*(H_{m}-H_{m-1})      
!          msh%cs(i)%surfaceArea(j)=demi* &                                            !S_m=0.5*
!               (msh%cs(i)%surfacewidth(j-1)+msh%cs(i)%surfacewidth(j))*&   !(w_{m-1}+w_{m})*
!               (msh%cs(i)%height(j)-msh%cs(i)%height(j-1))                 !(H_{m}-H_{m-1})
! 
!          !St_m=St_{m-1}+S_m
!          msh%cs(i)%surfaceAreaSum(j)=msh%cs(i)%surfaceAreaSum(j-1) + msh%cs(i)%surfaceArea(j)!St_m=St_{m-1}+S_m
! 
!       end do
!    end do
! 
!    !===================================================================================================================!
!    !  Recomputation of perimeter and alpha
!    !===================================================================================================================!
!    
!    do i = 1,msh%ncs+4
!       k=msh%cs(i)%nc
!       
!       !Pe0=w_0+2*(H_0-z_b)
!       msh%cs(i)%perimeter(1)= msh%cs(i)%surfacewidth(1)+ &                               !Pe0=w_0+
!                                          two*(msh%cs(i)%height(1)-bathy_cell(i))   !2*(H_0-z_b)
!       msh%cs(i)%perimeterp1(1)= (msh%cs(i)%height(1)-bathy_cell(i))
!       msh%cs(i)%perimeterp2(1)= (msh%cs(i)%height(1)-bathy_cell(i))
! 
!       msh%cs(i)%perimeterSum(1)=msh%cs(i)%perimeter(1) !Sum Pe0=Pe0
! 
!       do j=2,k
!          !Pe1_i=((0.5*W_i-(0.5*W_{i-1}-y_i))^2+(H_i-H_{i-1})^2)^(1/2)
!          !Pe2_i=((0.5*W_i-(0.5*W_{i-1}+y_i))^2+(H_i-H_{i-1})^2)^(1/2)
!          !Pe_i=Pe1_i+Pe2_i
!          wi=msh%cs(i)%surfacewidth(j)
!          wim1=msh%cs(i)%surfacewidth(j-1)
!          Hi=msh%cs(i)%height(j)
!          Him1=msh%cs(i)%height(j-1)
!          yi=msh%cs(i)%y(j-1)-msh%cs(i)%y(j)
! 
!          msh%cs(i)%perimeterp1(j)=sqrt((demi*wi-(demi*wim1-yi))**2+(Hi-Him1)**2) !((0.5*W_i-(0.5*W_{i-1}-y_i))^2+(H_i-H_{i-1})^2)^(1/2)
!          msh%cs(i)%perimeterp2(j)=sqrt((demi*wi-(demi*wim1+yi))**2+(Hi-Him1)**2) !((0.5*W_i-(0.5*W_{i-1}+y_i))^2+(H_i-H_{i-1})^2)^(1/2)
! 
!          msh%cs(i)%perimeter(j)=msh%cs(i)%perimeterp1(j)+msh%cs(i)%perimeterp2(j) !p1+p2
! 
!          msh%cs(i)%perimeterSum(j)=msh%cs(i)%perimeterSum(j-1)+msh%cs(i)%perimeter(j)
! 
!       end do
!    end do
! 
!    !===================================================================================================================!
!    !  Recomputation of w_derivative for pressure term computation
!    !===================================================================================================================!
!    
!    do i = 3,msh%ncs+2
!       k=msh%cs(i)%nc
!       !do j=1,k
!       do j=1,k-1
!          msh%cs(i)%zint  (j) = msh%cs(i)%height(j)-bathy_cell(i)
!          msh%cs(i)%wl    (j) = GetWFromH(msh,msh%cs(i)%height(j)-bathy_cell(i),i-1)
!          msh%cs(i)%wr    (j) = GetWFromH(msh,msh%cs(i)%height(j)-bathy_cell(i),i+1)
!       end do
!    end do

   
!   open(99, file="bathy_tmp.txt", status='replace')
!   do k = 1, size(bathy_cell)
!     write(99, *) bathy_cell(k)
!   end do
!   close(99)
!   print *, "BATHY_TMP SAVED"
!   read(*,*)
!             


END SUBROUTINE calc_bathymetry




!**********************************************************************************************************************!
!**********************************************************************************************************************!
!
!  Compute mean slope
!
!**********************************************************************************************************************!
!**********************************************************************************************************************!

!>  Compute mean slope
!!
!! \details This subroutine compute the bathymetry mean slope
!! \param[in]    msh Mesh of the problem.

SUBROUTINE calc_bathymetry_mean_slope(msh)
  USE m_mesh
   USE m_model
   USE m_numeric
   USE m_user_data
   USE m_obs

   implicit none

!======================================================================================================================!
!  Interface Variables
!======================================================================================================================!

   type(Mesh), intent(in   )  ::  msh

   do i = 3, msh%ncs+1
      bathy_slopemean = bathy_slopemean + (bathy_cell(i+1) - bathy_cell(i)) / msh%cs(i+1)%deltademi
   end do
   bathy_slopemean = bathy_slopemean / real(msh%ncs-1)
  
END SUBROUTINE calc_bathymetry_mean_slope
