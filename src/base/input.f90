!======================================================================================================================!
!
!                    DassFlow1D Version 2.1
!
!======================================================================================================================!
!
!  Copyright University of Toulouse-INSA - CNRS (France)
!
!  This file is part of the DassFlow software (Data Assimilation for Free Surface Flows).
!  DassFlow is a computational software aiming at simulating geophysical free surface flows.
!  It is designed for Variational Data Assimilation (4D-var) and sensitivity analyses. 
! Inverse capabilities are based on the adjoint code which is generated by 
! a source-to-source algorithmic differentiation (Tapenade software used).
!
!  DassFlow software includes few mostly independent "modules" with common architectures and structures:
!    - DassFlow 2DShallow (shallow water equations in (h,q), finite volumes), i.e. the present code.
!    - DassFlow3D  (non-linear Stokes equations, finite elements, mobile geometries, ALE).
!    - DassFlow 1D (shallow water equations in (S,Q), finite volumes or finite differences), river hydraulics.
!  Please consult the DassFlow webpage for more details: http://www.math.univ-toulouse.fr/DassFlow
!
! You have used DassFlow in an article, a scientific document etc ?  How to cite us ? Please consult the webpage.
! 
!  Many people have contributed to the DassFlow developments from the initial version to the latest ones.
!  Current main developers or scientific contributers are:
!               P. Brisset (CNES & Mathematics Institute of Toulouse & INSA Toulouse)
!               F. Couderc (CNRS & Mathematics Institute of Toulouse IMT)
!               P.-A. Garambois (INSA & ICUBE Strasbourg)
!               J. Monnier (INSA & Mathematics Institute of Toulouse IMT).
!               J.-P. Vila (INSA & Mathematics Institute of Toulouse IMT).
!  and former other developers (R. Madec, M. Honnorat and J. Marin).
!
!  Scientific contact : jerome.monnier@insa-toulouse.fr
!  Technical  contacts : frederic.couderc@math.univ-toulouse.fr, pierre.brisset@insa-toulouse.fr
!
!  This software is governed by the CeCILL license under French law and abiding by the rules of distribution
!  of free software. You can use, modify and/or redistribute the software under the terms of the CeCILL license
!  as circulated by CEA, CNRS and INRIA at the following URL: "http://www.cecill.info".
!
!  As a counterpart to the access to the source code and rights to copy, modify and redistribute granted by the
!  license, users are provided only with a limited warranty and the software's author, the holder of the economic
!  rights, and the successive licensors have only limited liability.
!
!  In this respect, the user's attention is drawn to the risks associated with loading, using, modifying and/or
!  developing or reproducing the software by the user in light of its specific status of free software, that may
!  mean that it is complicated to manipulate, and that also therefore means that it is reserved for developers and
!  experienced professionals having in-depth computer knowledge. Users are therefore encouraged to load and test the
!  software's suitability as regards their requirements in conditions enabling the security of their systems and/or
!  data to be ensured and, more generally, to use and operate it in the same conditions as regards security.
!
!  The fact that you are presently reading this means that you have had knowledge of the CeCILL license and that you
!  accept its terms.
!
!======================================================================================================================!
!> \file input.f90
!! \brief This file includes subroutine which read DassFlow msh file and input.txt.
!! \details The subroutine considerates in this file are read_input(), mesh_input() and read_dass_mesh().

! #define KH_FULLY_DISTRIBUTED


!**********************************************************************************************************************!
!**********************************************************************************************************************!
!
!  Read Input Variables ( Reading input.txt and Filling namelist )
!
!**********************************************************************************************************************!
!**********************************************************************************************************************!

!> Read input variables (reading input.txt and filling namelist ). 
!!
!! \details This subroutines read the input.txt file and keep input.txt value in the namelist.
!! 
SUBROUTINE Read_Input()

#if defined USE_SW_MONO || USE_SW_MULTI || USE_NS_MULTIFLUID

      USE m_model

#else

      USE m_user_test

#endif

   implicit none

   !===================================================================================================================!
   !
   !===================================================================================================================!

   call Default_values

   !===================================================================================================================!
   !
   !===================================================================================================================!

   call Print_Screen('read_input')


   write(buffer,'(A)') "sed -e '/^!/d;/^$/d;s/!.*//g;s/[ \t]//g' input.txt > input.post"

   call system( buffer )

   open(10,file='input.post',form='formatted',status='old')

   read(10,nml=list_input)

   close(10)
   
   ! BACKWARD COMPATIBILITY
   if (len_trim(regul_type) > 0) then
      if (regul_type == "iterative") then
         print *, "[ WARNING ] regul_type='iterative' in input.txt is deprecated."
         print *, "            Use 'var_chg=True' instead"
         var_chg = .true.
      else
         write(*,*) "[ ERROR ] regul_type must be 'iterative' in input.txt for backward compatibility"
         stop
      end if
   end if
   
   if (alpha > -9999.0_rp) then
      print *, "[ WARNING ] alpha and beta for Strickler in input.txt is deprecated."
      print *, "            Use file 'strickler_params.txt' instead"
   end if
      
   
END SUBROUTINE



 !**********************************************************************************************************************!
!**********************************************************************************************************************!
!
!  Read parameters defining the Strickler coefficient
!
!**********************************************************************************************************************!
!**********************************************************************************************************************!

!> Read parameters defining the Strickler coefficient
!!
!! \details This subroutine reads the manning_params.txt file and fills the K_params variable
 !!
 SUBROUTINE read_strickler_params(msh)
   USE m_model
   USE m_mesh
   USE m_common
   
   implicit none

   type(Mesh), intent(in)  ::  msh
   type( vec2d )  ::  pt_s, pt_e
   integer(ip) :: search_nearest_cross_section
   real(rp) :: alphaK, betaK
   integer(ip) :: cs_save


   inquire( file = 'strickler_params.txt' , exist = file_exist(1) )
   
   if ( file_exist(1) ) then
      open(10,file='strickler_params.txt',status='old')
      read(10,*)   ! comment
      read(10,*) K_params%nb_diff_K_reachs ! nb of reachs with differents Manning parameters
      i = K_params%nb_diff_K_reachs
      read(10,*)   ! comment
      read(10,*) K_params%nb_K_params  ! nb of parameters defining the Strickler coeff K
      if( K_model == 'K(h)' ) then
         allocate(K_params%alpha(msh%ncs+4))
         allocate(K_params%beta(msh%ncs+4))
      else if( K_model == 'Einstein3' ) then
         allocate(K_params%coeffs(3, msh%ncs+4))
      end if
      allocate(K_params%cs_start(i))
      allocate(K_params%cs_end(i))
      read(10,*)   ! comment
      ! read params
      cs_save = 0
      do j = 1,i
         read(10,*) pt_s%x, pt_s%y, pt_e%x, pt_e%y, alphaK, betaK ! a voir si faut mettre un if pour alpha, beta ???
         ! Get cross-sections indexes corresponding to the (x,y) points
         K_params%cs_start(j) = search_nearest_cross_section( msh , pt_s )
         if (cs_save == K_params%cs_start(j)) K_params%cs_start(j) = K_params%cs_start(j) + 1
         K_params%cs_end(j) = search_nearest_cross_section( msh , pt_e )
         cs_save = K_params%cs_end(j)
         if( K_model == 'K(h)' ) then
            K_params%alpha(K_params%cs_start(j)) = alphaK
            K_params%beta(K_params%cs_start(j)) = betaK
         end if
      end do

      close(10)
      
   else
   
      if (alpha < -9999.0_rp + 1e-2) then
      
         write(*,*) "[ ERROR ] file 'strickler_params.txt' not found"
         stop
        
      end if
      if( K_model == 'K(h)' ) then
         allocate(K_params%alpha(msh%ncs+4))
         allocate(K_params%beta(msh%ncs+4))
      end if
      
#ifdef KH_FULLY_DISTRIBUTED
      allocate(K_params%cs_start(msh%ncs))
      allocate(K_params%cs_end(msh%ncs))
      K_params%nb_diff_K_reachs = msh%ncs
      do i = 1, msh%ncs
        K_params%cs_start(i) = 2 + i
        K_params%cs_end(i) = 2 + i
        K_params%alpha(K_params%cs_start(i)) = alpha
        K_params%beta(K_params%cs_start(i)) = beta
      end do
#else
      allocate(K_params%cs_start(1))
      allocate(K_params%cs_end(1))
      
      K_params%nb_diff_K_reachs = 1
      K_params%cs_start(1) = 3
      K_params%cs_end(1) = msh%ncs+2
      K_params%alpha(K_params%cs_start(1)) = alpha
      K_params%beta(K_params%cs_start(1)) = beta
#endif
      
   end if

 END SUBROUTINE read_strickler_params


!**********************************************************************************************************************!
!**********************************************************************************************************************!
!
!  Main Mesh Creation Subroutine
!
!**********************************************************************************************************************!
!**********************************************************************************************************************!

!> Main msh creation Subroutine. 
!!
!! \details This subroutine read msh defined by user (only Dassflow format avaible for this time).
!! \param[inout] msh Mesh of the model.
SUBROUTINE Mesh_Input( msh )

   USE m_common
   USE m_mesh
   USE m_time_screen

   implicit none

!======================================================================================================================!
!  Interface Variables
!======================================================================================================================!

   type(Mesh), intent(inout)  ::  msh

!======================================================================================================================!
!  Local Variables
!======================================================================================================================!

   integer :: status

!======================================================================================================================!
!  Calling appropriate Subroutine
!======================================================================================================================!
   
   call Read_Dass_Mesh( msh, status )
   if (status /= 0) then
      print *, "[ ERROR ] Errors detected in msh"
      stop
   end if



END SUBROUTINE Mesh_Input


!**********************************************************************************************************************!
!**********************************************************************************************************************!
!
!  Mesh reader in Dassflow format
!
!**********************************************************************************************************************!
!**********************************************************************************************************************!


!> Mesh reader in Dassflow format
!!
!! \details This subroutine read msh defined by user  in the Dassflow format.
!! \param[inout] msh Mesh of the model.
SUBROUTINE Read_Dass_Mesh( msh, status )

   USE m_common
   USE m_mesh
   USE m_model
   USE m_time_screen

   implicit none

   !===================================================================================================================!
   !  Interface Variables
   !===================================================================================================================!

   type(Mesh), intent(out)  ::  msh
   integer :: status

   !===================================================================================================================!
   !  Local Variables
   !===================================================================================================================!

   integer(ip)  ::  neighb(4) , n1 , n2 , nc_bc , nb_grp_in , nb_grp_out , num_grp , bc_number, nc_to_read

   real(rp)  ::  ghost_cell_bathy
   real(rp)  ::  last_slope

   character(6)  ::  bc_type

   !===================================================================================================================!
   !  Begin Subroutine
   !===================================================================================================================!

   status = 0
   
   call Print_Screen( 'start_mesh' )

   if ((addPointsW.ne.0).or.(addPointsE.ne.0).or.(remesh.ne.0)) then
      msh%file_name=trim(mesh_name)//'_used'
   else
      msh%file_name = mesh_name
   endif

  
   open(10,file=msh%file_name,status='old')

   !===================================================================================================================!
   !  Reading header
   !===================================================================================================================!

   read(10,*)  !Read first line (comment)
   read(10,*) msh%ncs , msh%scal

   allocate( msh%cs( msh%ncs+4 ) )
   allocate( bathy_cell( msh%ncs+4 ) )
   allocate( tflux1(msh%ncs+4))
   allocate( tflux2(msh%ncs+4))
   tflux1(:) = 0._rp
   tflux2(:) = 0._rp


   !===================================================================================================================!
   !  Reading cross section 
   !===================================================================================================================!

   read(10,*)
   do i = 1,msh%ncs
      !Get Cross-section definition
      read(10,*)  k ,&                                   ! Number of Cross section
                  msh%cs(k+2)%coord%x , &     ! Coordinates x 
                  msh%cs(k+2)%coord%y , &     ! Coordinates y
                  msh%cs(k+2)%bathy, &    ! Elevation
                  msh%cs(k+2)%nlevels              ! Number of triple

      if (crosssection_extrapolation == "constant") then
         nc_to_read = msh%cs(k+2)%nlevels
      else if (crosssection_extrapolation == "linear") then
         msh%cs(k+2)%nlevels=msh%cs(k+2)%nlevels+1
         nc_to_read = msh%cs(k+2)%nlevels-1
      else if (crosssection_extrapolation == "linear_builtin1") then
         msh%cs(k+2)%nlevels=msh%cs(k+2)%nlevels+1
         nc_to_read = msh%cs(k+2)%nlevels-1
      else
         write(*,*) "[ ERROR ] 'crosssection_extrapolation' must be 'constant' or 'linear1'"
         status = -1
      end if
      allocate(msh%cs(k+2)%height(msh%cs(k+2)%nlevels))         ! Allocate height
      allocate(msh%cs(k+2)%width(msh%cs(k+2)%nlevels))   ! Allocate surfaceWidth
      allocate(msh%cs(k+2)%y(msh%cs(k+2)%nlevels))              ! Allocate gap

      !Get triplet ( Height, Surface width and gap)
      do j=1,nc_to_read
         read(10,*)  msh%cs(k+2)%height(j),&           !Height
                     msh%cs(k+2)%width(j),&            !Surface width
                     msh%cs(k+2)%y(j)                  !Gap
                     
         !=============================================================================================================!
         ! CHECK-UP : Ensure that surfce width is positive
         !=============================================================================================================!
         if (msh%cs(k+2)%width(j) < 1e-12_rp) then
             write(*,*) '[ ERROR ] width ', j, 'for crosssection ', k, 'is negative or zero'
             status = -2
          end if
                     
         !=============================================================================================================!
         ! CHECK-UP : Ensure that elevation are in increasing order
         !=============================================================================================================!
         if (j == 1) then
            if (msh%cs(k+2)%height(j) < msh%cs(k+2)%bathy + 1e-12) then
              write(*,*) '[ ERROR ] height ', j, 'for crosssection ', k, 'is lower than or equal to bottom elevation'
              status = -3
            end if
         else
            if (msh%cs(k+2)%height(j) < msh%cs(k+2)%height(j-1) + 1e-12) then
              write(*,*) '[ ERROR ] height ', j, 'for crosssection ', k, 'is lower than or equal to previous elevation'
              status = -3
            end if
         end if
      end do

      j=msh%cs(k+2)%nlevels
      if (crosssection_extrapolation == "linear") then
         msh%cs(k+2)%height(j)=msh%cs(k+2)%height(j-1)+100._rp
         last_slope = (msh%cs(k+2)%width(j-1) - msh%cs(k+2)%width(j-2)) / &
                      (msh%cs(k+2)%height(j-1) - msh%cs(k+2)%height(j-2))
         msh%cs(k+2)%width(j) = msh%cs(k+2)%width(j-1) + 100._rp * last_slope
         msh%cs(k+2)%y(j)=msh%cs(k+2)%y(j-1)
      else if (crosssection_extrapolation == "linear_builtin1") then
         msh%cs(k+2)%height(j)=msh%cs(k+2)%height(j-1)+100._rp
         msh%cs(k+2)%width(j)=msh%cs(k+2)%width(j-1)+100000._rp
         msh%cs(k+2)%y(j)=msh%cs(k+2)%y(j-1)
      end if

   end do

   !Set gap 1 to 0
   msh%cs(3)%y(1)=zero


   !Fill gost cell (W_boundary)
   do i=1,2
      msh%cs(i)%coord%x  =msh%cs(3)%coord%x  
      msh%cs(i)%coord%y  =msh%cs(3)%coord%y 
      msh%cs(i)%bathy=msh%cs(3)%bathy
      msh%cs(i)%nlevels       =msh%cs(3)%nlevels
      allocate(msh%cs(i)%height(msh%cs(i)%nlevels))
      allocate(msh%cs(i)%width(msh%cs(i)%nlevels))
      allocate(msh%cs(i)%y(msh%cs(i)%nlevels))
      do j=1,msh%cs(i)%nlevels
         msh%cs(i)%height(j)      =msh%cs(3)%height(j)
         msh%cs(i)%width(j)=msh%cs(3)%width(j)
         msh%cs(i)%y(j)           =msh%cs(3)%y(j)
      end do
   end do

   !Fill gost cell (E_boundary)
   do i=msh%ncs+3,msh%ncs+4
      msh%cs(i)%coord%x  =msh%cs(msh%ncs+2)%coord%x  
      msh%cs(i)%coord%y  =msh%cs(msh%ncs+2)%coord%y 
      msh%cs(i)%bathy=msh%cs(msh%ncs+2)%bathy
      msh%cs(i)%nlevels       =msh%cs(msh%ncs+2)%nlevels
      allocate(msh%cs(i)%height(msh%cs(i)%nlevels))
      allocate(msh%cs(i)%width(msh%cs(i)%nlevels))
      allocate(msh%cs(i)%y(msh%cs(i)%nlevels))
      do j=1,msh%cs(i)%nlevels
         msh%cs(i)%height(j)      =msh%cs(msh%ncs+2)%height(j)
         msh%cs(i)%width(j)=msh%cs(msh%ncs+2)%width(j)
         msh%cs(i)%y(j)           =msh%cs(msh%ncs+2)%y(j)
      end do
   end do

   !Fill bathy_cell
   do i=1,msh%ncs+4
      bathy_cell(i)=msh%cs(i)%bathy
   end do

   ! Create segment
   allocate(msh%seg(1))
   msh%seg(1)%first_cs = 3
   msh%seg(1)%last_cs = msh%ncs+2
   do i=1,msh%ncs+4
      bathy_cell(i)=msh%cs(i)%bathy
   end do
   
   ! Set real number of cross-sections (ghost+real)
   msh%ncs = msh%ncs + 4

   !===================================================================================================================!
   !  Finishing Subroutine
   !===================================================================================================================!

   
   close(10)
   
   if (status /= 0) return

   call Print_Screen( 'end_mesh' )

END SUBROUTINE Read_Dass_Mesh



